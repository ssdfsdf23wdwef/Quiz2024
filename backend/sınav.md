# SÄ±nav OluÅŸturma Promptu

## Tarih: 2025-05-31T14:36:59.598Z

## Trace ID: quiz-1748702219587-oxju5

## Alt Konular (9 adet):
```
## AKTÄ°F KONULAR (SORU ÃœRETÄ°LECEK)

**AÅŸaÄŸÄ±daki alt konular iÃ§in belirtilen sayÄ±da soru Ã¼retilecektir:**

1. **Paralel Programlama ParadigmalarÄ±** (2 soru)
2. **PaylaÅŸÄ±mlÄ± Bellek ParadigmasÄ±** (2 soru)
3. **DaÄŸÄ±tÄ±k Bellek ParadigmasÄ±** (2 soru)
4. **Hibrit Paralel Programlama** (2 soru)
5. **DÃ¶ngÃ¼ AÃ§ma Loop Unrolling** (2 soru)

**Toplam Aktif: 5 alt konu, 10 soru**

## BEKLEYEN KONULAR (SORU ÃœRETÄ°LMEYECEK)

**AÅŸaÄŸÄ±daki konulardan soru Ã¼retilmeyecektir:**

1. DÃ¶ngÃ¼ BirleÅŸtirme Loop Fusion
2. VektÃ¶rizasyon Vectorization
3. Profilleme AraÃ§larÄ±
4. Hata AyÄ±klama AraÃ§larÄ±

```

## Soru SayÄ±sÄ±: 10

## Zorluk: mixed

## Tam Prompt:
```
// ====================================================
// ============ TEST SORULARI OLUÅTURMA PROMPT ============
// ====================================================

**ğŸ“‹ TEMEL GÃ–REV:** 
Sen bir eÄŸitim iÃ§eriÄŸi ve test geliÅŸtirme uzmanÄ±sÄ±n. Verilen metin iÃ§eriÄŸini derinlemesine analiz ederek, kaliteli ve iÃ§erik-odaklÄ± test sorularÄ± oluÅŸturacaksÄ±n.

// ----------------------------------------------------
// ------------------- GÄ°RDÄ°LER -----------------------
// ----------------------------------------------------

**ğŸ“¥ GÄ°RDÄ°LER:**
- **Konu Bilgileri:** ## AKTÄ°F KONULAR (SORU ÃœRETÄ°LECEK)

**AÅŸaÄŸÄ±daki alt konular iÃ§in belirtilen sayÄ±da soru Ã¼retilecektir:**

1. **Paralel Programlama ParadigmalarÄ±** (2 soru)
2. **PaylaÅŸÄ±mlÄ± Bellek ParadigmasÄ±** (2 soru)
3. **DaÄŸÄ±tÄ±k Bellek ParadigmasÄ±** (2 soru)
4. **Hibrit Paralel Programlama** (2 soru)
5. **DÃ¶ngÃ¼ AÃ§ma Loop Unrolling** (2 soru)

**Toplam Aktif: 5 alt konu, 10 soru**

## BEKLEYEN KONULAR (SORU ÃœRETÄ°LMEYECEK)

**AÅŸaÄŸÄ±daki konulardan soru Ã¼retilmeyecektir:**

1. DÃ¶ngÃ¼ BirleÅŸtirme Loop Fusion
2. VektÃ¶rizasyon Vectorization
3. Profilleme AraÃ§larÄ±
4. Hata AyÄ±klama AraÃ§larÄ±

  *LÃ¼tfen dikkat: Bu bÃ¶lÃ¼mde "AKTÄ°F KONULAR (SORU ÃœRETÄ°LECEK)" ve "BEKLEYEN KONULAR (SORU ÃœRETÄ°LMEYECEK)" olmak Ã¼zere iki liste gÃ¶rebilirsin.*
- **EÄŸitim Ä°Ã§eriÄŸi:** 

Bilgisayar MÃ¼hendisliÄŸi BÃ¶lÃ¼mÃ¼
Bahar â€“2025(Ã–Ã–.,Ä°Ã–.)
MBM7-452 -Eksaskala Bilgisayar Sistemleri
(Sunu 3)
Dr. Ã–ÄŸr. Ãœyesi Esra Ã‡elik

GÃ¼nÃ¼n Sorusu
Eksaskala bilgisayarlarda kullanÄ±lan
programlama modelleri ve araÃ§larÄ±
nelerdir?

Programlama Modelleri ve AraÃ§larÄ±
â€¢Programlama modelleri ve araÃ§larÄ±,
â€¢tasarÄ±mcÄ±lara eksaskala sistemlerin yÃ¼ksek hesaplama gÃ¼cÃ¼nÃ¼
kullanabilmeleri iÃ§in bir kÃ¶prÃ¼ gÃ¶revi gÃ¶rÃ¼r.
â€¢Eksaskala bilgisayar sistemleri iÃ§in kritik bir roloynar.
â€¢Programlamada kullanÄ±lan en temel modeller ve araÃ§lar:
â€¢Paralel Programlama ParadigmalarÄ±
â€¢Derleyici OptimizasyonlarÄ±
â€¢Performans Profilleme ve Hata AyÄ±klamaâ€™dir.

Paralel Programlama ParadigmalarÄ±
â€¢Eksaskala sistemlerde verimliliÄŸi artÄ±rmak iÃ§in paralellikgÃ¼cÃ¼nden yararlanÄ±lÄ±r.
â€¢Paralel programlama paradigmasÄ±:
â€¢Bir iÅŸlemin kÃ¼Ã§Ã¼k parÃ§alara bÃ¶lÃ¼nerek aynÄ± anda birden fazla iÅŸlemcide
yÃ¼rÃ¼tÃ¼lmesini saÄŸlayan yazÄ±lÄ±mlardÄ±r.
â€¢BÃ¼yÃ¼k Ã¶lÃ§ekli hesaplamalarda performansÄ± maksimize etmek iÃ§in kritik bir
bileÅŸendir.

Paralel Programlama ParadigmalarÄ±
â€¢Eksaskala sistemlerde kullanÄ±lan baÅŸlÄ±ca paralel programlama
paradigmalarÄ± ÅŸunlardÄ±r:
â€¢PaylaÅŸÄ±mlÄ± Bellek ParadigmasÄ±
â€¢DaÄŸÄ±tÄ±k Bellek ParadigmasÄ±
â€¢Hibrit Paralel Programlama

Paralel Programlama ParadigmalarÄ±
â€¢PaylaÅŸÄ±mlÄ± bellek paradigmasÄ±:
â€¢Ã‡ok Ã§ekirdekli iÅŸlemciler iÃ§in idealdir;
tÃ¼m iÅŸlemciler ortak belleÄŸe eriÅŸir.
â€¢Bu paradigmada:
â€¢OpenMP, mevcut koda direktifler
ekleyerek uygulama geliÅŸtirmeyi
kolaylaÅŸtÄ±rÄ±r.
â€¢DÃ¼ÅŸÃ¼k iletiÅŸim gecikmesi avantajÄ±dÄ±r.

Paralel Programlama ParadigmalarÄ±
â€¢OpenMP (Open Multi-Processing),
â€¢Ã§ok Ã§ekirdekli iÅŸlemciler ve paylaÅŸÄ±mlÄ± bellek mimarileriile paralel uygulamalar
geliÅŸtirmek iÃ§in kullanÄ±lÄ±r.
â€¢Eksaskala sistemlerde, her dÃ¼ÄŸÃ¼mdeki yÃ¼ksek Ã§ekirdek sayÄ±sÄ± sayesinde gÃ¶revlerin paralel
Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±na olanak tanÄ±r.
â€¢Paralellik saÄŸlamak iÃ§in derleyici direktiflerikullanÄ±lÄ±r. Ã–rneÄŸin,
â€¢#pragma omp parallel direktifi, paralel bir bÃ¶lge baÅŸlatÄ±r ve derleyici, kapsanan gÃ¶revleri
paralel Ã§alÄ±ÅŸtÄ±rmak iÃ§in kod Ã¼retir.
â€¢#pragma omp for direktifi, for-dÃ¶ngÃ¼lerinin paralelleÅŸtirilmesi iÃ§in kullanÄ±lÄ±r.

Paralel Programlama ParadigmalarÄ±
â€¢DaÄŸÄ±tÄ±k bellek paradigmasÄ±
â€¢Her iÅŸlemci kendi dÃ¼ÄŸÃ¼mÃ¼nÃ¼n
belleÄŸine eriÅŸir; veri deÄŸiÅŸimi
mesajlaÅŸmaile saÄŸlanÄ±r.
â€¢Bu paradigmada:
â€¢MPI,yaygÄ±n olarak kullanÄ±lÄ±r.
â€¢MesajlaÅŸma ek yÃ¼k getirebilir.

Paralel Programlama ParadigmalarÄ±
â€¢Message Passing Interface (MPI),
â€¢daÄŸÄ±tÄ±k bellekli ortamlarda paralel uygulamalar geliÅŸtirmek iÃ§in kullanÄ±lÄ±r.
â€¢Eksaskala sistemlerde baÄŸÄ±msÄ±z iÅŸlemciler arasÄ±nda veri alÄ±ÅŸveriÅŸi ve paralel gÃ¶rev
koordinasyonu saÄŸlanÄ±r.
â€¢MPI, iÅŸlemler arasÄ±nda doÄŸrudan veri alÄ±ÅŸveriÅŸi saÄŸlayan point-to-point iletiÅŸim
mekanizmalarÄ± sunar.
â€¢Ã–rneÄŸin MPI_Send ve MPI_Recv fonksiyonlarÄ±.
MPI

Paralel Programlama ParadigmalarÄ±
â€¢Hibrit paralellik,
â€¢farklÄ± paralel programlama paradigmalarÄ±nÄ±n gÃ¼cÃ¼nden yararlanmak iÃ§in birden fazla
paradigma birleÅŸtirir.
â€¢Eksaskala biliÅŸimde,
â€¢MPI ve OpenMP paralellik modellerinin kombinasyonu yaygÄ±n bir hibrit
yaklaÅŸÄ±mdÄ±r.
â€¢Bu hibrit yaklaÅŸÄ±m,
â€¢hem her bir dÃ¼ÄŸÃ¼mlerdeki paralel iÅŸlem hemde tÃ¼m sistem genelindeki paralel
iÅŸlemlerinverimli bir ÅŸekilde yapÄ±lmasÄ±nÄ± saÄŸlar.
â€¢MPI, iÅŸlemler arasÄ± iletiÅŸimsaÄŸlarken, OpenMP, dÃ¼ÄŸÃ¼m iÃ§indeki paralellikten faydalanarak
paralelleme verimliliÄŸini artÄ±rÄ±r.
MPI

Paralel Programlama ParadigmalarÄ±
â€¢MPI + OpenMP kombinasyonunda:
â€¢MPI:Ä°ÅŸlemciler arasÄ± iletiÅŸim saÄŸlar (dÄ±ÅŸ paralelleÅŸtirme).
â€¢OpenMP: Ã‡ok Ã§ekirdekli iÅŸlemciler iÃ§inde iÅŸ parÃ§acÄ±klarÄ±nÄ± yÃ¶netir (iÃ§
paralelleÅŸtirme).
â€¢AvantajÄ±:
â€¢Daha fazla iÅŸlem gÃ¼cÃ¼ ve daha hÄ±zlÄ± veri iÅŸleme.
â€¢Kaynak kullanÄ±mÄ±nÄ± optimize eder.
â€¢OpenMP, paylaÅŸÄ±mlÄ± bellek iÃ§inde Ã§alÄ±ÅŸarak MPIâ€™nin iletiÅŸim yÃ¼kÃ¼nÃ¼ azaltÄ±r ve
performansÄ± artÄ±rÄ±r.

Derleyici OptimizasyonlarÄ±
â€¢Derleyici optimizasyonlarÄ±:
â€¢kaynak kodun yÃ¼ksek verimli makine koduna dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmesi sÃ¼recidir.
â€¢Eksaskala sistemlerde amaÃ§,
â€¢hesaplama verimliliÄŸini artÄ±rmak ve bellek eriÅŸim gecikmesini azaltÄ±lmaktÄ±r.
â€¢Derleyici optimizasyonu ile performans iyileÅŸtirimesinde,
â€¢dÃ¶ngÃ¼ aÃ§ma,
â€¢dÃ¶ngÃ¼ birleÅŸtirme
â€¢ve dÃ¶ngÃ¼ vektÃ¶rleÅŸtirme teknikleri kullanÄ±lÄ±r.
â€¢Bu optimizasyonlar, eksaskala sistemlerde optimal performanssaÄŸlamak iÃ§in gereklidir.
Derleyici
Optimizasyonu
Kaynak
kodu
Makine
kodu
(yÃ¼ksek
verimli)
Hatalar

Derleyici OptimizasyonlarÄ±
â€¢DÃ¶ngÃ¼ aÃ§ma (Loop Unrolling),
â€¢dÃ¶ngÃ¼ kontrol yapÄ±larÄ±nÄ±n yÃ¼kÃ¼nÃ¼ azaltmayÄ± amaÃ§layan bir derleyici
optimizasyon tekniÄŸidir.
â€¢Birden fazla iterasyon tek bir dÃ¶ngÃ¼de aÃ§Ä±lÄ±r ve bu da iÅŸlemcinin birden fazla talimatÄ±
aynÄ± anda Ã§alÄ±ÅŸtÄ±rmasÄ±nÄ± mÃ¼mkÃ¼n kÄ±lar.
â€¢DÃ¶ngÃ¼ aÃ§ma, derleyicinin daha fazla talimat seviyesinde paralellik aÃ§Ä±ÄŸa Ã§Ä±karmasÄ±nÄ±
saÄŸlar.
ï”
Peki ama
nasÄ±l?

Derleyici OptimizasyonlarÄ±
â€¢Ã–rneÄŸin, N Ã§ift sayÄ± olsun:
for (int i = 0; i < N; i++) {
array[i] = array[i] * 2;
}
â€¢YukarÄ±dakidÃ¶ngÃ¼de dÃ¶ngÃ¼ kontrolÃ¼ (i'nin artÄ±rÄ±lmasÄ± ve i < N koÅŸulunun kontrolÃ¼) her
iterasyonda bir kez Ã§alÄ±ÅŸÄ±r.
â€¢Her iterasyon bir dizi elemanÄ±nÄ± iÅŸler, toplamda N iterasyon yapÄ±lÄ±r.
ï”
Bu dÃ¶ngÃ¼yÃ¼ nasÄ±l
aÃ§abilirsiniz?

Derleyici OptimizasyonlarÄ±
Ã‡Ã¶zÃ¼m:
â€¢Her iterasyonda tek eleman yerine iki eleman iÅŸleyerek toplam iterasyon sayÄ±sÄ±nÄ±
yarÄ±yaindirebilirsiniz. Bunun iÃ§in:
â€¢i deÄŸerini 2 artÄ±rÄ±larak dÃ¶ngÃ¼ye giriÅŸ yapÄ±lÄ±r(i += 2).
â€¢N yerine N/2 iterasyon gerÃ§ekleÅŸir.
â€¢Bu ÅŸekildebirbirine baÄŸlÄ± olmayaniki eleman(array[i]ve array[i + 1])aynÄ± anda
iÅŸlenirve paralellikoluÅŸur.
for (int i = 0; i < N; i += 2) {Ã¶rneÄŸin bu satÄ±r core 1 ile iÅŸlenir.
array[i] = array[i] * 2;
array[i + 1] = array[i + 1] * 2;bu satÄ±r core 2 ile iÅŸlenir.
}

Derleyici OptimizasyonlarÄ±
DÃ¶ngÃ¼ koÅŸulunun kontrol edilmesi ve i'nin artÄ±rÄ±lmasÄ± daha az
yapÄ±lÄ±r.
Her iterasyonda iÅŸlenen eleman sayÄ±sÄ± arttÄ±rÄ±lÄ±r.
Paralellik saÄŸlanÄ±r.
Daha az iÅŸlem daha hÄ±zlÄ± sonuÃ§ alÄ±nÄ±r.
ïƒ¼
ïƒ¼
DÃ¶ngÃ¼ aÃ§ma ile birlikte:
ïƒ¼
ïƒ¼

Derleyici OptimizasyonlarÄ±
â€¢DÃ¶ngÃ¼ aÃ§mada dikkat edilmesi gereken en temel faktÃ¶r dÃ¶ngÃ¼ sÄ±nÄ±rlarÄ±dÄ±r.
â€¢Ã–rneÄŸin:
for (int i = 0; i < N; i++) {
array[i] = array[i] * 2;
}
â€¢YukarÄ±daki dÃ¶ndÃ¼ yapÄ±sÄ±nda N tek sayÄ±ise,
â€¢son iterasyon (yani i == N -1) array[i + 1]'e eriÅŸmeye Ã§alÄ±ÅŸacaktÄ±r,
â€¢bu da sÄ±nÄ±r dÄ±ÅŸÄ± bellek eriÅŸimine yol aÃ§abilir.
ï”
Bu sorunu nasÄ±l
Ã§Ã¶zersiniz?

Derleyici OptimizasyonlarÄ±
Ã‡Ã¶zÃ¼m:
â€¢N tek olduÄŸunda dÃ¶ngÃ¼ iÃ§indeki elemanlar (Ã¶rneÄŸin array[0] ve array[1], array[2] ve
array[3]) Ã§ifter Ã§ifter iÅŸlenir.
â€¢Sadece son eleman (Ã¶rneÄŸin array[N-1]) dÃ¶ngÃ¼ dÄ±ÅŸÄ±ndabir kez iÅŸlenir.
for (int i = 0; i < N -1; i += 2) {
array[i] = array[i] * 2; Ã¶rneÄŸin bu satÄ±r core 1 ile iÅŸlenir.
array[i + 1] = array[i + 1] * 2; bu satÄ±r core 2 ile iÅŸlenir.
}
array[N -1] = array[N -1] * 2;

Derleyici OptimizasyonlarÄ±
â€¢DÃ¶ngÃ¼ birleÅŸtirme (Loop Fusion),
â€¢iki veya daha fazla dÃ¶ngÃ¼nÃ¼n tek bir dÃ¶ngÃ¼de birleÅŸtirilmesi iÅŸlemidir.
â€¢Eksaskala sistemlerde bu optimizasyon,
â€¢bellek eriÅŸimini iyileÅŸtirmek ve dÃ¶ngÃ¼ baÅŸlatma maliyetlerini azaltmakiÃ§in
kullanÄ±lÄ±r.
ï”
Peki ama
nasÄ±l?

Derleyici OptimizasyonlarÄ±
â€¢Ã–rneÄŸin, aÅŸaÄŸÄ±daki iki ayrÄ± dÃ¶ngÃ¼olsun:
for (int i = 0; i < N; i++) {
A[i] = B[i] * 2;
}
for (int i = 0; i < N; i++) {
C[i] = A[i]+ 5;
}
â€¢Bu kodda ilk dÃ¶ngÃ¼ A dizisini hesaplar, ikinci dÃ¶ngÃ¼ ise A'nÄ±n sonuÃ§larÄ±nÄ± C dizisine
iÅŸler.
â€¢A dizisine iki kez eriÅŸilir:
â€¢Birinci dÃ¶ngÃ¼de yazÄ±lÄ±r, ikinci dÃ¶ngÃ¼de okunur.
â€¢Bu da gereksiz bellek eriÅŸimine neden olur.

Derleyici OptimizasyonlarÄ±
Ã‡Ã¶zÃ¼m:
â€¢Bu iki dÃ¶ngÃ¼yÃ¼ tek bir dÃ¶ngÃ¼yebirleÅŸtirerek bellek eriÅŸimini optimize edebiliriz:
for (int i = 0; i < N; i++) {
A[i]= B[i] * 2;
C[i] = A[i] + 5;
}
â€¢A[i] birinci satÄ±rda hesaplanÄ±r ve hemen ikinci satÄ±rda kullanÄ±lÄ±r.
â€¢Tek bir dÃ¶ngÃ¼ baÅŸlatÄ±lÄ±r.
â€¢Bellek eriÅŸimi azaltÄ±lÄ±r.
Seri
programlama
kullanÄ±lmakta

Derleyici OptimizasyonlarÄ±
BaÄŸÄ±msÄ±z iÅŸlem adÄ±mlarÄ± iÃ§eren dÃ¶ngÃ¼ler varsa (Ã–rneÄŸin A[i]
Ã¶nce hesaplanÄ±p sonra C[i]'de kullanÄ±lÄ±yorsa)
Diziler arasÄ±ndaki veri baÄŸÄ±mlÄ±lÄ±ÄŸÄ± yoksa
Yada veri baÄŸÄ±mlÄ±lÄ±ÄŸÄ± kontrol ediliyorsa
Bellek performansÄ± artÄ±rÄ±lmak isteniyorsa
ïƒ¼
ïƒ¼
DÃ¶ngÃ¼ birleÅŸtirme ne zaman kullanÄ±lÄ±r?
ïƒ¼
ïƒ¼

Derleyici OptimizasyonlarÄ±
â€¢VektÃ¶rizasyon (Vectorization):
â€¢Tek Komut Ã‡oklu Veri (SIMD) paralelliÄŸiolarak da bilinen bir
optimizasyon tekniÄŸidir.
â€¢Bu teknik,
â€¢aynÄ± iÅŸlemci komutunun birden fazla veri elemanÄ±na aynÄ± anda
uygulanmasÄ±nÄ± saÄŸlar
â€¢Ã–zellikle diziler veya vektÃ¶rler Ã¼zerinde Ã§alÄ±ÅŸan dÃ¶ngÃ¼ler iÃ§in oldukÃ§a
etkilidir.
â€¢Modern iÅŸlemciler, SIMD komut setleri (SSE, AVX, Neon vb.) ile vektÃ¶r
iÅŸlemlerini hÄ±zlandÄ±rÄ±r.

Derleyici OptimizasyonlarÄ±
â€¢Ã–rneÄŸin 8 elemanlÄ± bir dizininher elemanÄ± 2 ile Ã§arpÄ±lmak istensin:
â€¢Skaler iÅŸlem yapÄ±lÄ±r. Yani standart bir for dÃ¶ngÃ¼sÃ¼yle her elemanÄ± tek tek Ã§arpÄ±lÄ±r:
int array[8] = {1, 2, 3, 4, 5, 6, 7, 8};
for (int i = 0; i < 8; i++) {
array[i] = array[i] * 2;
}
â€¢Ä°ÅŸlem AdÄ±mlarÄ±:
â€¢Ä°lk iterasyon: array[0] = 1 * 2
â€¢Ä°kinci iterasyon: array[1] = 2 * 2
â€¢ÃœÃ§Ã¼ncÃ¼ iterasyon: array[2] = 3 * 2
â€¢...
â€¢Sekizinci iterasyon: array[7] = 8 * 2
â€¢Toplamda 8 iÅŸlem yapÄ±lÄ±r (8 dÃ¶ngÃ¼ turu).
ï”
Bu iÅŸlem
vektÃ¶rleÅŸtirme
ile nasÄ±l olur?

Derleyici OptimizasyonlarÄ±
Ã‡Ã¶zÃ¼m 1:
â€¢4â€™lÃ¼ SIMDile VektÃ¶rizasyonda4 tane sayÄ± tek seferde iÅŸlenebilir.
int array[8] = {1, 2, 3, 4, 5, 6, 7, 8};
#pragma omp simd
for (int i = 0; i < 8; i++) {
array[i] = array[i] * 2;
}
â€¢Ä°ÅŸlem adÄ±mlarÄ±:
â€¢Ä°lk adÄ±mda iÅŸlemci 4 elemanÄ± aynÄ± andaÃ§arpar: {1, 2, 3, 4} * 2 â†’ {2, 4, 6, 8}
â€¢Ä°kinci adÄ±mda diÄŸer 4 elemanÄ± aynÄ± anda Ã§arpar: {5, 6, 7, 8} * 2 â†’ {10, 12, 14, 16}
â€¢Toplamda 2 dÃ¶ngÃ¼ turu ile iÅŸlem tamamlanÄ±r.

Derleyici OptimizasyonlarÄ±
Ã‡Ã¶zÃ¼m 2:
â€¢8â€™lÃ¼ SIMDile VektÃ¶rizasyonda8tane sayÄ± tek seferde iÅŸlenebilir.
int array[8] = {1, 2, 3, 4, 5, 6, 7, 8};
#pragma omp simd
for (int i = 0; i < 8; i++) {
array[i] = array[i] * 2;
}
â€¢Ä°ÅŸlem adÄ±mlarÄ±:
â€¢Tek adÄ±mda iÅŸlemci 8elemanÄ± aynÄ± andaÃ§arpar:
â€¢{1, 2, 3, 4, 5, 6, 7, 8} * 2 â†’ {2, 4, 6, 8, 10, 12, 14, 16}
â€¢Toplamda 1 dÃ¶ngÃ¼ turu ile iÅŸlem tamamlanÄ±r.

Derleyici OptimizasyonlarÄ±
Tek bir saat dÃ¶ngÃ¼sÃ¼nde birden fazla veri elemanÄ±nÄ± iÅŸler.
Ä°ÅŸlem sÃ¼resini hÄ±zlandÄ±rÄ±r.
Bellekten okuma ve yazma iÅŸlemlerinin sayÄ±sÄ±nÄ± azaltÄ±r.
GÃ¼Ã§ tÃ¼ketimini azaltÄ±r.
ïƒ¼
ïƒ¼
VektÃ¶rizasyonun avantajlarÄ± nelerdir?
ïƒ¼
ïƒ¼

Performans Profilleme ve Hata AyÄ±klama
â€¢Eksaskala sistemlerde, iÅŸlemci veya Ã§ekirdek sayÄ±sÄ± arttÄ±kÃ§a uygulamanÄ±n
performansÄ± analiz edilir.
â€¢Profilleme ve hata ayÄ±klama,
â€¢Eksaskala sistemlerde kod verimliliÄŸini optimize etmek ve performans
sorunlarÄ±nÄ± tespit etmek iÃ§in kullanÄ±lÄ±r.
â€¢Profilleme,
â€¢programÄ±n Ã§alÄ±ÅŸma zamanÄ± davranÄ±ÅŸÄ±nÄ± analiz etmeye ve darboÄŸazlarÄ± tespit
etmeyeyardÄ±mcÄ± olur.
â€¢Hata ayÄ±klama,
â€¢performans, eÅŸzamanlÄ±lÄ±k ve kaynak kullanÄ±mÄ±yla ilgili hatalarÄ± giderir ve
programÄ±n doÄŸruluÄŸunu saÄŸlar.

Performans Profilleme ve Hata AyÄ±klama
â€¢Eksaskala sistemlerde profilleme araÃ§larÄ± genel olarak iÅŸlemci, bellek ve I/O
kullanÄ±mÄ±gibi farklÄ± kaynaklarÄ±n nasÄ±l kullanÄ±ldÄ±ÄŸÄ±nÄ± analiz eder.
â€¢Eksaskala sistemlerde en sÄ±k kullanÄ±lan profilleme araÃ§lar:
â€¢Intel VTune Amplifier
â€¢Cray Pat
â€¢TAU (Tuning and Analysis Utilities)
â€¢gprof
â€¢perf

Performans Profilleme ve Hata AyÄ±klama
â€¢Eksaskala sistemlerde hata ayÄ±klama araÃ§larÄ± genel olarak bellek hatalarÄ±, veri
yarÄ±ÅŸlarÄ± gibi hatalarÄ± analiz eder.
â€¢Eksaskala sistemlerde en sÄ±k kullanÄ±lan hata ayÄ±klama araÃ§larÄ±:
â€¢TotalView
â€¢GDB (GNU Debugger)
â€¢Allinea DDT
â€¢Intel Debugger (IDB)
- **Ä°stenen Toplam Soru SayÄ±sÄ±:** 10 soru
- **Zorluk Seviyesi:** mixed

// ----------------------------------------------------
// ------------- METÄ°N ANALÄ°Z SÃœRECÄ° -----------------
// ----------------------------------------------------

**ğŸ” Ä°Ã‡ERÄ°K ANALÄ°Z ADIMLARI:**
1. Ã–nce metni dikkatlice oku ve anla
2. "Konu Bilgileri" bÃ¶lÃ¼mÃ¼ndeki "AKTÄ°F KONULAR (SORU ÃœRETÄ°LECEK)" listesindeki alt konulara odaklan
3. Her bir aktif alt konu iÃ§in anahtar kavramlarÄ± tespit et
4. Her kavram iÃ§in Ã¶ÄŸrenilmesi gereken temel noktalarÄ± listele
5. Ä°Ã§eriÄŸin mantÄ±k akÄ±ÅŸÄ±nÄ± ve bÃ¶lÃ¼mleri arasÄ±ndaki iliÅŸkiyi kavra

**âš ï¸ METÄ°N SORUNLARIYLA BAÅA Ã‡IKMA:**
- EÄŸer metin formatÄ± bozuk gÃ¶rÃ¼nÃ¼yorsa (satÄ±r sonlarÄ± eksik vb.), cÃ¼mle yapÄ±sÄ±nÄ± anlamaya Ã§alÄ±ÅŸ
- AnlamsÄ±z veya hatalÄ± karakterler varsa yok say
- Metin kÄ±sÄ±mlarÄ± eksik veya kopuk gÃ¶rÃ¼nÃ¼yorsa, mevcut bilgilerden yararlanan sorular oluÅŸtur
- TÃ¼rkÃ§e karakter sorunlarÄ± varsa (ÅŸ, Ã§, ÄŸ, Ã¼, Ã¶, Ä±) anlamÄ± koruyarak dÃ¼zelt

// ----------------------------------------------------
// ------------- SORU OLUÅTURMA KURALLARI ------------
// ----------------------------------------------------

**â­ ALT KONU DAÄILIMI VE SORU KURGULAMASI:**
1. SADECE "Konu Bilgileri" bÃ¶lÃ¼mÃ¼ndeki "AKTÄ°F KONULAR (SORU ÃœRETÄ°LECEK)" listesinde belirtilen alt konular iÃ§in soru Ã¼ret
2. "BEKLEYEN KONULAR (SORU ÃœRETÄ°LMEYECEK)" listesindeki konulardan KESÄ°NLÄ°KLE soru ÃœRETME
3. Her aktif alt konu iÃ§in tam olarak o alt konu yanÄ±nda belirtilen sayÄ±da soru Ã¼ret
   Ã–rneÄŸin: "Nesne YÃ¶nelimli Programlama (3 soru)" ifadesi, bu konu iÃ§in tam 3 soru oluÅŸturulmalÄ±dÄ±r
4. Toplam soru sayÄ±sÄ±nÄ±n 10 olduÄŸundan emin ol (Bu sayÄ±, aktif konulardaki toplam soru sayÄ±sÄ±na eÅŸit olmalÄ±dÄ±r)
5. Belirtilen aktif alt konular ve soru sayÄ±larÄ±na MUTLAKA UYULMALIDIR
6. Her sorunun hangi alt konuya ait olduÄŸu JSON Ã§Ä±ktÄ±sÄ±nda "subTopicName" alanÄ±nda AÃ‡IKÃ‡A belirtilmelidir
7. Her soruyu Ã¼retirken, o sorunun hangi aktif alt konudan geldiÄŸini mutlaka kontrol et
8. Soru daÄŸÄ±lÄ±mlarÄ± dengesiz olabilir! Ã–rneÄŸin: "Veri YapÄ±larÄ±" iÃ§in 5 soru, "Algoritma Analizi" iÃ§in 2 soru

**ğŸ“Š ZORLUK SEVÄ°YELERÄ° (SADECE Ä°NGÄ°LÄ°ZCE KULLAN):**
- "easy" (kolay): Temel hatÄ±rlama ve anlama sorularÄ±
- "medium" (orta): Uygulama ve analiz sorularÄ±
- "hard" (zor): KarmaÅŸÄ±k analiz, deÄŸerlendirme ve yaratma sorularÄ±
- "mixed" (karÄ±ÅŸÄ±k): FarklÄ± zorluk seviyelerinin karÄ±ÅŸÄ±mÄ±

**ğŸ§  BLOOM TAKSONOMÄ°SÄ° DÃœZEYLERÄ°:**
- Kolay (easy): "remembering", "understanding"
- Orta (medium): "applying", "analyzing" (temel dÃ¼zeyde)
- Zor (hard): "analyzing" (karmaÅŸÄ±k), "evaluating", "creating"

**ğŸ“ SORU TÃœRLERÄ° VE KULLANIM:**
- "multiple_choice": KavramlarÄ± test etmek iÃ§in en yaygÄ±n format (4 ÅŸÄ±k)
- "true_false": YaygÄ±n yanlÄ±ÅŸ anlamalarÄ± test etmek iÃ§in ideal
- "fill_in_blank": Terminoloji ve kesin bilgi iÃ§in
- "short_answer": Ã–ÄŸrencinin kendi ifadesiyle aÃ§Ä±klamasÄ±nÄ± gerektiren konular iÃ§in

**ğŸ“‹ TEMEL KURALLAR:**
1. Sorular SADECE verilen iÃ§eriÄŸe dayanmalÄ±, dÄ±ÅŸarÄ±dan bilgi eklenmemeli
2. Her soru bir alt konuyu Ã¶lÃ§meli ve doÄŸrudan iÃ§erikle ilgili olmalÄ±
3. Her sorunun TEK doÄŸru cevabÄ± olmalÄ±, bu cevap aÃ§Ä±kÃ§a iÃ§erikte belirtilmiÅŸ olmalÄ±
4. Ã‡eldiriciler (yanlÄ±ÅŸ ÅŸÄ±klar) makul ama ayÄ±rt edilebilir olmalÄ±
5. Konu daÄŸÄ±lÄ±mÄ±nda belirtilen aÄŸÄ±rlÄ±klara uyulmalÄ±
6. Sorular kavramsal anlayÄ±ÅŸÄ± Ã¶lÃ§meli, sadece ezber bilgiyi deÄŸil
7. Metin iÃ§indeki kelimeler birebir kopyalanmak yerine yeniden ifade edilmeli

**ğŸ’¡ AÃ‡IKLAMA YAZMA KURALLARI:**
- Her aÃ§Ä±klama, doÄŸru cevabÄ± net ÅŸekilde belirtmeli
- AÃ§Ä±klamada Ã¶ÄŸrenciyi iÃ§eriÄŸin ilgili bÃ¶lÃ¼mÃ¼ne yÃ¶nlendirmeli
- Sadece neyin doÄŸru olduÄŸunu deÄŸil, neden doÄŸru olduÄŸunu da aÃ§Ä±klamalÄ±
- Ã‡eldiricilerin neden yanlÄ±ÅŸ olduÄŸunu kÄ±saca belirtmeli
- KÄ±sa ve Ã¶z olmalÄ±, ama yeterince bilgilendirici olmalÄ±

// ----------------------------------------------------
// -------------- JSON Ã‡IKTI FORMATI -----------------
// ----------------------------------------------------

**âš™ï¸ JSON Ã‡IKTI KURALLARI:**
- YanÄ±t SADECE geÃ§erli bir JSON nesnesi olmalÄ±dÄ±r, ek aÃ§Ä±klama iÃ§ermemelidir
- JSON dÄ±ÅŸÄ±nda hiÃ§bir ek metin eklenmemelidir
- JSON yapÄ±sÄ± tam ve doÄŸru olmalÄ± - tÃ¼m parantezleri dengeli olmalÄ±
- Zorunlu alanlar: id, questionText, options, correctAnswer, explanation, subTopicName, difficulty
- Her soru iÃ§in zorluk seviyesi SADECE Ä°ngilizce olmalÄ± ("easy", "medium", "hard", "mixed")

**ğŸ“„ JSON FORMATI:**
```
{
  "questions": [
    {
      "id": "q1",
      "questionText": "Soru metni?",
      "questionType": "multiple_choice",
      "cognitiveDomain": "remembering",
      "options": ["SeÃ§enek A", "SeÃ§enek B", "SeÃ§enek C", "SeÃ§enek D"],
      "correctAnswer": "SeÃ§enek B",
      "explanation": "DoÄŸru cevabÄ±n aÃ§Ä±klamasÄ±",
      "subTopicName": "Nesne YÃ¶nelimli Programlama",
      "normalizedSubTopicName": "nesne_yonelimli_programlama",
      "difficulty": "medium"
    },
    {
      "id": "q2",
      "questionText": "Ä°kinci soru metni?",
      "questionType": "multiple_choice",
      "cognitiveDomain": "understanding",
      "options": ["SeÃ§enek A", "SeÃ§enek B", "SeÃ§enek C", "SeÃ§enek D"],
      "correctAnswer": "SeÃ§enek A",
      "explanation": "DoÄŸru cevabÄ±n aÃ§Ä±klamasÄ±",
      "subTopicName": "Nesne YÃ¶nelimli Programlama",
      "normalizedSubTopicName": "nesne_yonelimli_programlama",
      "difficulty": "easy"
    },
    {
      "id": "q3",
      "questionText": "ÃœÃ§Ã¼ncÃ¼ soru metni?",
      "questionType": "multiple_choice",
      "cognitiveDomain": "applying",
      "options": ["SeÃ§enek A", "SeÃ§enek B", "SeÃ§enek C", "SeÃ§enek D"],
      "correctAnswer": "SeÃ§enek C",
      "explanation": "DoÄŸru cevabÄ±n aÃ§Ä±klamasÄ±",
      "subTopicName": "Nesne YÃ¶nelimli Programlama",
      "normalizedSubTopicName": "nesne_yonelimli_programlama",
      "difficulty": "medium"
    },
    {
      "id": "q4",
      "questionText": "BaÅŸka bir alt konudan soru?",
      "questionType": "multiple_choice",
      "cognitiveDomain": "analyzing",
      "options": ["SeÃ§enek A", "SeÃ§enek B", "SeÃ§enek C", "SeÃ§enek D"],
      "correctAnswer": "SeÃ§enek D",
      "explanation": "DoÄŸru cevabÄ±n aÃ§Ä±klamasÄ±",
      "subTopicName": "Algoritma Analizi",
      "normalizedSubTopicName": "algoritma_analizi",
      "difficulty": "hard"
    }
  ]
}
```

// ----------------------------------------------------
// -------------- KALÄ°TE KRÄ°TERLERÄ° ------------------
// ----------------------------------------------------

**ğŸ¯ SORU KALÄ°TESÄ° KRÄ°TERLERÄ°:**
1. Ä°Ã‡ERÄ°K ODAKLILIK: Her soru, direkt olarak verilen metinden Ã§Ä±karÄ±lmalÄ±
2. AÃ‡IKLIK: Soru ifadeleri aÃ§Ä±k, net ve anlaÅŸÄ±lÄ±r olmalÄ±
3. UYGUNLUK: Zorluk seviyesi ve biliÅŸsel dÃ¼zey uyumlu olmalÄ±
4. DENGELÄ° Ã‡ELDÄ°RÄ°CÄ°LER: YanlÄ±ÅŸ ÅŸÄ±klar mantÄ±klÄ± ama aÃ§Ä±kÃ§a yanlÄ±ÅŸ olmalÄ±
5. KAVRAMSAL DERINLIK: YÃ¼zeysel bilgi yerine kavramsal anlayÄ±ÅŸÄ± Ã¶lÃ§meli
6. DÄ°L KALÄ°TESÄ°: TÃ¼rkÃ§e dilbilgisi ve yazÄ±m kurallarÄ±na uygun olmalÄ±

**âœ… SON KONTROLLER:**
- TÃ¼m sorularÄ±n doÄŸru cevaplarÄ± kesinlikle metinde yer almalÄ±
- Zorluk seviyeleri MUTLAKA Ä°ngilizce olmalÄ± ("easy", "medium", "hard", "mixed")
- JSON formatÄ±nÄ±n doÄŸruluÄŸundan emin ol
- Sorular farklÄ± biliÅŸsel dÃ¼zeyleri iÃ§ermeli
- TÃ¼m gerekli alanlar doldurulmalÄ±
- ALT KONU DAÄILIMI ve SORU SAYISI:
  1. Toplam soru sayÄ±sÄ± tam olarak 10 adet olmalÄ± (aktif konulardaki toplam soru sayÄ±sÄ±yla eÅŸleÅŸmeli)
  2. "Konu Bilgileri" bÃ¶lÃ¼mÃ¼ndeki "AKTÄ°F KONULAR (SORU ÃœRETÄ°LECEK)" listesindeki HER BÄ°R alt konu iÃ§in belirtilen SORU SAYISINA MUTLAKA uyulmalÄ±
     Ã–rneÄŸin: "Veri TabanÄ± Sistemleri (3 soru)" yazÄ±yorsa, bu konudan tam 3 soru Ã¼retilmeli
  3. "BEKLEYEN KONULAR (SORU ÃœRETÄ°LMEYECEK)" listesindeki konulardan KESÄ°NLÄ°KLE soru Ã¼retilmediÄŸinden emin ol
  4. Her sorunun "subTopicName" alanÄ±nda, o sorunun geldiÄŸi alt konunun TAM ADI belirtilmeli
     Ã–rneÄŸin: "Nesne YÃ¶nelimli Programlama", "Veri YapÄ±larÄ±" gibi konu adlarÄ± aynen kullanÄ±lmalÄ±
- Her alt konu iÃ§in sorularÄ±n zorluk daÄŸÄ±lÄ±mÄ± dengeli olmalÄ±

// ====================================================
// ================ PROMPT SONU ======================
// ====================================================
```



## Ä°ÅŸlenen Sorular Analizi:

- Toplam Soru SayÄ±sÄ±: 10
- Alt Konu DaÄŸÄ±lÄ±mÄ±:

  - Paralel Programlama ParadigmalarÄ±: 2 soru
  - PaylaÅŸÄ±mlÄ± Bellek ParadigmasÄ±: 2 soru
  - DaÄŸÄ±tÄ±k Bellek ParadigmasÄ±: 2 soru
  - Hibrit Paralel Programlama: 2 soru
  - DÃ¶ngÃ¼ AÃ§ma Loop Unrolling: 2 soru


### Soru Ã–rnekleri (Her Alt Konudan 1 Adet):

#### Paralel Programlama ParadigmalarÄ±:
- Soru: AÅŸaÄŸÄ±dakilerden hangisi eksaskala sistemlerde verimliliÄŸi artÄ±rmak iÃ§in kullanÄ±lan temel yaklaÅŸÄ±mlardan biridir?
- SeÃ§enekler: Tek Ã§ekirdekli iÅŸlemci kullanÄ±mÄ± | Paralellikten yararlanma | Bellek eriÅŸimini en aza indirme | Seri programlama
- DoÄŸru Cevap: Paralellikten yararlanma
- Zorluk: medium

#### PaylaÅŸÄ±mlÄ± Bellek ParadigmasÄ±:
- Soru: PaylaÅŸÄ±mlÄ± bellek paradigmasÄ± iÃ§in aÅŸaÄŸÄ±dakilerden hangisi doÄŸrudur?
- SeÃ§enekler: Her iÅŸlemci kendi Ã¶zel belleÄŸine sahiptir. | TÃ¼m iÅŸlemciler ortak bir belleÄŸe eriÅŸir. | Veri iletiÅŸimi mesajlaÅŸma yoluyla saÄŸlanÄ±r. | Sadece daÄŸÄ±tÄ±k sistemlerde kullanÄ±lÄ±r.
- DoÄŸru Cevap: TÃ¼m iÅŸlemciler ortak bir belleÄŸe eriÅŸir.
- Zorluk: easy

#### DaÄŸÄ±tÄ±k Bellek ParadigmasÄ±:
- Soru: DaÄŸÄ±tÄ±k bellek paradigmasÄ±nda veri deÄŸiÅŸimi nasÄ±l saÄŸlanÄ±r?
- SeÃ§enekler: Ortak bir bellek alanÄ± Ã¼zerinden | MesajlaÅŸma ile | PaylaÅŸÄ±mlÄ± deÄŸiÅŸkenler aracÄ±lÄ±ÄŸÄ±yla | Sanal bellek yÃ¶netimi ile
- DoÄŸru Cevap: MesajlaÅŸma ile
- Zorluk: easy

#### Hibrit Paralel Programlama:
- Soru: Hibrit paralel programlama yaklaÅŸÄ±mÄ±nÄ±n temel Ã¶zelliÄŸi nedir?
- SeÃ§enekler: Sadece paylaÅŸÄ±mlÄ± bellek paradigmasÄ±nÄ± kullanmasÄ± | Sadece daÄŸÄ±tÄ±k bellek paradigmasÄ±nÄ± kullanmasÄ± | FarklÄ± paralel programlama paradigmalarÄ±nÄ±n gÃ¼cÃ¼nden yararlanmak iÃ§in birden fazla paradigmayÄ± birleÅŸtirmesi | Sadece tek Ã§ekirdekli iÅŸlemcilerde Ã§alÄ±ÅŸmasÄ±
- DoÄŸru Cevap: FarklÄ± paralel programlama paradigmalarÄ±nÄ±n gÃ¼cÃ¼nden yararlanmak iÃ§in birden fazla paradigmayÄ± birleÅŸtirmesi
- Zorluk: easy

#### DÃ¶ngÃ¼ AÃ§ma Loop Unrolling:
- Soru: DÃ¶ngÃ¼ aÃ§ma (Loop Unrolling) tekniÄŸinin temel amacÄ± nedir?
- SeÃ§enekler: DÃ¶ngÃ¼ kontrol yapÄ±larÄ±nÄ±n yÃ¼kÃ¼nÃ¼ azaltmak | DÃ¶ngÃ¼leri birleÅŸtirerek bellek eriÅŸimini artÄ±rmak | DÃ¶ngÃ¼leri vektÃ¶rleÅŸtirerek SIMD paralelliÄŸi saÄŸlamak | DÃ¶ngÃ¼leri tamamen ortadan kaldÄ±rmak
- DoÄŸru Cevap: DÃ¶ngÃ¼ kontrol yapÄ±larÄ±nÄ±n yÃ¼kÃ¼nÃ¼ azaltmak
- Zorluk: easy

