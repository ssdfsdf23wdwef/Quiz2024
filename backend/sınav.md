# SÄ±nav OluÅŸturma Promptu

## Tarih: 2025-05-22T12:25:15.032Z

## Trace ID: quiz-1747916715005-8urwa

## Alt Konular (10 adet):
```
## AKTÄ°F KONULAR (SORU ÃœRETÄ°LECEK)

**AÅŸaÄŸÄ±daki alt konular iÃ§in belirtilen sayÄ±da soru Ã¼retilecektir:**

1. **Programlama Modelleri Ve Ara Lar** (2 soru)
2. **Paralel Programlama Paradigmalar** (2 soru)
3. **Derleyici Optimizasyonlar** (2 soru)
4. **Performans Profilleme Ve Hata Ay Klama** (2 soru)
5. **Payla Ml Bellek Paradigmas** (2 soru)

**Toplam Aktif: 5 alt konu, 10 soru**

## BEKLEYEN KONULAR (SORU ÃœRETÄ°LMEYECEK)

**AÅŸaÄŸÄ±daki konulardan soru Ã¼retilmeyecektir:**

1. Da T K Bellek Paradigmas
2. Hibrit Paralel Programlama
3. D NÄŸi A Ma Loop UnrollinÄŸi
4. D NÄŸi Birle Tirme Loop Fusion
5. Vekt Rizasyon Vectorization

```

## Soru SayÄ±sÄ±: 10

## Zorluk: mixed

## Tam Prompt:
```
// ====================================================
// ============ TEST SORULARI OLUÅTURMA PROMPT ============
// ====================================================

**ğŸ“‹ TEMEL GÃ–REV:** 
Sen bir eÄŸitim iÃ§eriÄŸi ve test geliÅŸtirme uzmanÄ±sÄ±n. Verilen metin iÃ§eriÄŸini derinlemesine analiz ederek, kaliteli ve iÃ§erik-odaklÄ± test sorularÄ± oluÅŸturacaksÄ±n.

// ----------------------------------------------------
// ------------------- GÄ°RDÄ°LER -----------------------
// ----------------------------------------------------

**ğŸ“¥ GÄ°RDÄ°LER:**
- **Konu Bilgileri:** ## AKTÄ°F KONULAR (SORU ÃœRETÄ°LECEK)

**AÅŸaÄŸÄ±daki alt konular iÃ§in belirtilen sayÄ±da soru Ã¼retilecektir:**

1. **Programlama Modelleri Ve Ara Lar** (2 soru)
2. **Paralel Programlama Paradigmalar** (2 soru)
3. **Derleyici Optimizasyonlar** (2 soru)
4. **Performans Profilleme Ve Hata Ay Klama** (2 soru)
5. **Payla Ml Bellek Paradigmas** (2 soru)

**Toplam Aktif: 5 alt konu, 10 soru**

## BEKLEYEN KONULAR (SORU ÃœRETÄ°LMEYECEK)

**AÅŸaÄŸÄ±daki konulardan soru Ã¼retilmeyecektir:**

1. Da T K Bellek Paradigmas
2. Hibrit Paralel Programlama
3. D NÄŸi A Ma Loop UnrollinÄŸi
4. D NÄŸi Birle Tirme Loop Fusion
5. Vekt Rizasyon Vectorization

  *LÃ¼tfen dikkat: Bu bÃ¶lÃ¼mde "AKTÄ°F KONULAR (SORU ÃœRETÄ°LECEK)" ve "BEKLEYEN KONULAR (SORU ÃœRETÄ°LMEYECEK)" olmak Ã¼zere iki liste gÃ¶rebilirsin.*
- **EÄŸitim Ä°Ã§eriÄŸi:** 

Bilgisayar MÃ¼hendisliÄŸi BÃ¶lÃ¼mÃ¼
Bahar â€“2025(Ã–Ã–.,Ä°Ã–.)
MBM7-452 -Eksaskala Bilgisayar Sistemleri
(Sunu 3)
Dr. Ã–ÄŸr. Ãœyesi Esra Ã‡elik

GÃ¼nÃ¼n Sorusu
Eksaskala bilgisayarlarda kullanÄ±lan
programlama modelleri ve araÃ§larÄ±
nelerdir?

Programlama Modelleri ve AraÃ§larÄ±
â€¢Programlama modelleri ve araÃ§larÄ±,
â€¢tasarÄ±mcÄ±lara eksaskala sistemlerin yÃ¼ksek hesaplama gÃ¼cÃ¼nÃ¼
kullanabilmeleri iÃ§in bir kÃ¶prÃ¼ gÃ¶revi gÃ¶rÃ¼r.
â€¢Eksaskala bilgisayar sistemleri iÃ§in kritik bir roloynar.
â€¢Programlamada kullanÄ±lan en temel modeller ve araÃ§lar:
â€¢Paralel Programlama ParadigmalarÄ±
â€¢Derleyici OptimizasyonlarÄ±
â€¢Performans Profilleme ve Hata AyÄ±klamaâ€™dir.

Paralel Programlama ParadigmalarÄ±
â€¢Eksaskala sistemlerde verimliliÄŸi artÄ±rmak iÃ§in paralellikgÃ¼cÃ¼nden yararlanÄ±lÄ±r.
â€¢Paralel programlama paradigmasÄ±:
â€¢Bir iÅŸlemin kÃ¼Ã§Ã¼k parÃ§alara bÃ¶lÃ¼nerek aynÄ± anda birden fazla iÅŸlemcide
yÃ¼rÃ¼tÃ¼lmesini saÄŸlayan yazÄ±lÄ±mlardÄ±r.
â€¢BÃ¼yÃ¼k Ã¶lÃ§ekli hesaplamalarda performansÄ± maksimize etmek iÃ§in kritik bir
bileÅŸendir.

Paralel Programlama ParadigmalarÄ±
â€¢Eksaskala sistemlerde kullanÄ±lan baÅŸlÄ±ca paralel programlama
paradigmalarÄ± ÅŸunlardÄ±r:
â€¢PaylaÅŸÄ±mlÄ± Bellek ParadigmasÄ±
â€¢DaÄŸÄ±tÄ±k Bellek ParadigmasÄ±
â€¢Hibrit Paralel Programlama

Paralel Programlama ParadigmalarÄ±
â€¢PaylaÅŸÄ±mlÄ± bellek paradigmasÄ±:
â€¢Ã‡ok Ã§ekirdekli iÅŸlemciler iÃ§in idealdir;
tÃ¼m iÅŸlemciler ortak belleÄŸe eriÅŸir.
â€¢Bu paradigmada:
â€¢OpenMP, mevcut koda direktifler
ekleyerek uygulama geliÅŸtirmeyi
kolaylaÅŸtÄ±rÄ±r.
â€¢DÃ¼ÅŸÃ¼k iletiÅŸim gecikmesi avantajÄ±dÄ±r.

Paralel Programlama ParadigmalarÄ±
â€¢OpenMP (Open Multi-Processing),
â€¢Ã§ok Ã§ekirdekli iÅŸlemciler ve paylaÅŸÄ±mlÄ± bellek mimarileriile paralel uygulamalar
geliÅŸtirmek iÃ§in kullanÄ±lÄ±r.
â€¢Eksaskala sistemlerde, her dÃ¼ÄŸÃ¼mdeki yÃ¼ksek Ã§ekirdek sayÄ±sÄ± sayesinde gÃ¶revlerin paralel
Ã§alÄ±ÅŸtÄ±rÄ±lmasÄ±na olanak tanÄ±r.
â€¢Paralellik saÄŸlamak iÃ§in derleyici direktiflerikullanÄ±lÄ±r. Ã–rneÄŸin,
â€¢#pragma omp parallel direktifi, paralel bir bÃ¶lge baÅŸlatÄ±r ve derleyici, kapsanan gÃ¶revleri
paralel Ã§alÄ±ÅŸtÄ±rmak iÃ§in kod Ã¼retir.
â€¢#pragma omp for direktifi, for-dÃ¶ngÃ¼lerinin paralelleÅŸtirilmesi iÃ§in kullanÄ±lÄ±r.

Paralel Programlama ParadigmalarÄ±
â€¢DaÄŸÄ±tÄ±k bellek paradigmasÄ±
â€¢Her iÅŸlemci kendi dÃ¼ÄŸÃ¼mÃ¼nÃ¼n
belleÄŸine eriÅŸir; veri deÄŸiÅŸimi
mesajlaÅŸmaile saÄŸlanÄ±r.
â€¢Bu paradigmada:
â€¢MPI,yaygÄ±n olarak kullanÄ±lÄ±r.
â€¢MesajlaÅŸma ek yÃ¼k getirebilir.

Paralel Programlama ParadigmalarÄ±
â€¢Message Passing Interface (MPI),
â€¢daÄŸÄ±tÄ±k bellekli ortamlarda paralel uygulamalar geliÅŸtirmek iÃ§in kullanÄ±lÄ±r.
â€¢Eksaskala sistemlerde baÄŸÄ±msÄ±z iÅŸlemciler arasÄ±nda veri alÄ±ÅŸveriÅŸi ve paralel gÃ¶rev
koordinasyonu saÄŸlanÄ±r.
â€¢MPI, iÅŸlemler arasÄ±nda doÄŸrudan veri alÄ±ÅŸveriÅŸi saÄŸlayan point-to-point iletiÅŸim
mekanizmalarÄ± sunar.
â€¢Ã–rneÄŸin MPI_Send ve MPI_Recv fonksiyonlarÄ±.
MPI

Paralel Programlama ParadigmalarÄ±
â€¢Hibrit paralellik,
â€¢farklÄ± paralel programlama paradigmalarÄ±nÄ±n gÃ¼cÃ¼nden yararlanmak iÃ§in birden fazla
paradigma birleÅŸtirir.
â€¢Eksaskala biliÅŸimde,
â€¢MPI ve OpenMP paralellik modellerinin kombinasyonu yaygÄ±n bir hibrit
yaklaÅŸÄ±mdÄ±r.
â€¢Bu hibrit yaklaÅŸÄ±m,
â€¢hem her bir dÃ¼ÄŸÃ¼mlerdeki paralel iÅŸlem hemde tÃ¼m sistem genelindeki paralel
iÅŸlemlerinverimli bir ÅŸekilde yapÄ±lmasÄ±nÄ± saÄŸlar.
â€¢MPI, iÅŸlemler arasÄ± iletiÅŸimsaÄŸlarken, OpenMP, dÃ¼ÄŸÃ¼m iÃ§indeki paralellikten faydalanarak
paralelleme verimliliÄŸini artÄ±rÄ±r.
MPI

Paralel Programlama ParadigmalarÄ±
â€¢MPI + OpenMP kombinasyonunda:
â€¢MPI:Ä°ÅŸlemciler arasÄ± iletiÅŸim saÄŸlar (dÄ±ÅŸ paralelleÅŸtirme).
â€¢OpenMP: Ã‡ok Ã§ekirdekli iÅŸlemciler iÃ§inde iÅŸ parÃ§acÄ±klarÄ±nÄ± yÃ¶netir (iÃ§
paralelleÅŸtirme).
â€¢AvantajÄ±:
â€¢Daha fazla iÅŸlem gÃ¼cÃ¼ ve daha hÄ±zlÄ± veri iÅŸleme.
â€¢Kaynak kullanÄ±mÄ±nÄ± optimize eder.
â€¢OpenMP, paylaÅŸÄ±mlÄ± bellek iÃ§inde Ã§alÄ±ÅŸarak MPIâ€™nin iletiÅŸim yÃ¼kÃ¼nÃ¼ azaltÄ±r ve
performansÄ± artÄ±rÄ±r.

Derleyici OptimizasyonlarÄ±
â€¢Derleyici optimizasyonlarÄ±:
â€¢kaynak kodun yÃ¼ksek verimli makine koduna dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmesi sÃ¼recidir.
â€¢Eksaskala sistemlerde amaÃ§,
â€¢hesaplama verimliliÄŸini artÄ±rmak ve bellek eriÅŸim gecikmesini azaltÄ±lmaktÄ±r.
â€¢Derleyici optimizasyonu ile performans iyileÅŸtirimesinde,
â€¢dÃ¶ngÃ¼ aÃ§ma,
â€¢dÃ¶ngÃ¼ birleÅŸtirme
â€¢ve dÃ¶ngÃ¼ vektÃ¶rleÅŸtirme teknikleri kullanÄ±lÄ±r.
â€¢Bu optimizasyonlar, eksaskala sistemlerde optimal performanssaÄŸlamak iÃ§in gereklidir.
Derleyici
Optimizasyonu
Kaynak
kodu
Makine
kodu
(yÃ¼ksek
verimli)
Hatalar

Derleyici OptimizasyonlarÄ±
â€¢DÃ¶ngÃ¼ aÃ§ma (Loop Unrolling),
â€¢dÃ¶ngÃ¼ kontrol yapÄ±larÄ±nÄ±n yÃ¼kÃ¼nÃ¼ azaltmayÄ± amaÃ§layan bir derleyici
optimizasyon tekniÄŸidir.
â€¢Birden fazla iterasyon tek bir dÃ¶ngÃ¼de aÃ§Ä±lÄ±r ve bu da iÅŸlemcinin birden fazla talimatÄ±
aynÄ± anda Ã§alÄ±ÅŸtÄ±rmasÄ±nÄ± mÃ¼mkÃ¼n kÄ±lar.
â€¢DÃ¶ngÃ¼ aÃ§ma, derleyicinin daha fazla talimat seviyesinde paralellik aÃ§Ä±ÄŸa Ã§Ä±karmasÄ±nÄ±
saÄŸlar.
ï”
Peki ama
nasÄ±l?

Derleyici OptimizasyonlarÄ±
â€¢Ã–rneÄŸin, N Ã§ift sayÄ± olsun:
for (int i = 0; i < N; i++) {
array[i] = array[i] * 2;
}
â€¢YukarÄ±dakidÃ¶ngÃ¼de dÃ¶ngÃ¼ kontrolÃ¼ (i'nin artÄ±rÄ±lmasÄ± ve i < N koÅŸulunun kontrolÃ¼) her
iterasyonda bir kez Ã§alÄ±ÅŸÄ±r.
â€¢Her iterasyon bir dizi elemanÄ±nÄ± iÅŸler, toplamda N iterasyon yapÄ±lÄ±r.
ï”
Bu dÃ¶ngÃ¼yÃ¼ nasÄ±l
aÃ§abilirsiniz?

Derleyici OptimizasyonlarÄ±
Ã‡Ã¶zÃ¼m:
â€¢Her iterasyonda tek eleman yerine iki eleman iÅŸleyerek toplam iterasyon sayÄ±sÄ±nÄ±
yarÄ±yaindirebilirsiniz. Bunun iÃ§in:
â€¢i deÄŸerini 2 artÄ±rÄ±larak dÃ¶ngÃ¼ye giriÅŸ yapÄ±lÄ±r(i += 2).
â€¢N yerine N/2 iterasyon gerÃ§ekleÅŸir.
â€¢Bu ÅŸekildebirbirine baÄŸlÄ± olmayaniki eleman(array[i]ve array[i + 1])aynÄ± anda
iÅŸlenirve paralellikoluÅŸur.
for (int i = 0; i < N; i += 2) {Ã¶rneÄŸin bu satÄ±r core 1 ile iÅŸlenir.
array[i] = array[i] * 2;
array[i + 1] = array[i + 1] * 2;bu satÄ±r core 2 ile iÅŸlenir.
}

Derleyici OptimizasyonlarÄ±
DÃ¶ngÃ¼ koÅŸulunun kontrol edilmesi ve i'nin artÄ±rÄ±lmasÄ± daha az
yapÄ±lÄ±r.
Her iterasyonda iÅŸlenen eleman sayÄ±sÄ± arttÄ±rÄ±lÄ±r.
Paralellik saÄŸlanÄ±r.
Daha az iÅŸlem daha hÄ±zlÄ± sonuÃ§ alÄ±nÄ±r.
ïƒ¼
ïƒ¼
DÃ¶ngÃ¼ aÃ§ma ile birlikte:
ïƒ¼
ïƒ¼

Derleyici OptimizasyonlarÄ±
â€¢DÃ¶ngÃ¼ aÃ§mada dikkat edilmesi gereken en temel faktÃ¶r dÃ¶ngÃ¼ sÄ±nÄ±rlarÄ±dÄ±r.
â€¢Ã–rneÄŸin:
for (int i = 0; i < N; i++) {
array[i] = array[i] * 2;
}
â€¢YukarÄ±daki dÃ¶ndÃ¼ yapÄ±sÄ±nda N tek sayÄ±ise,
â€¢son iterasyon (yani i == N -1) array[i + 1]'e eriÅŸmeye Ã§alÄ±ÅŸacaktÄ±r,
â€¢bu da sÄ±nÄ±r dÄ±ÅŸÄ± bellek eriÅŸimine yol aÃ§abilir.
ï”
Bu sorunu nasÄ±l
Ã§Ã¶zersiniz?

Derleyici OptimizasyonlarÄ±
Ã‡Ã¶zÃ¼m:
â€¢N tek olduÄŸunda dÃ¶ngÃ¼ iÃ§indeki elemanlar (Ã¶rneÄŸin array[0] ve array[1], array[2] ve
array[3]) Ã§ifter Ã§ifter iÅŸlenir.
â€¢Sadece son eleman (Ã¶rneÄŸin array[N-1]) dÃ¶ngÃ¼ dÄ±ÅŸÄ±ndabir kez iÅŸlenir.
for (int i = 0; i < N -1; i += 2) {
array[i] = array[i] * 2; Ã¶rneÄŸin bu satÄ±r core 1 ile iÅŸlenir.
array[i + 1] = array[i + 1] * 2; bu satÄ±r core 2 ile iÅŸlenir.
}
array[N -1] = array[N -1] * 2;

Derleyici OptimizasyonlarÄ±
â€¢DÃ¶ngÃ¼ birleÅŸtirme (Loop Fusion),
â€¢iki veya daha fazla dÃ¶ngÃ¼nÃ¼n tek bir dÃ¶ngÃ¼de birleÅŸtirilmesi iÅŸlemidir.
â€¢Eksaskala sistemlerde bu optimizasyon,
â€¢bellek eriÅŸimini iyileÅŸtirmek ve dÃ¶ngÃ¼ baÅŸlatma maliyetlerini azaltmakiÃ§in
kullanÄ±lÄ±r.
ï”
Peki ama
nasÄ±l?

Derleyici OptimizasyonlarÄ±
â€¢Ã–rneÄŸin, aÅŸaÄŸÄ±daki iki ayrÄ± dÃ¶ngÃ¼olsun:
for (int i = 0; i < N; i++) {
A[i] = B[i] * 2;
}
for (int i = 0; i < N; i++) {
C[i] = A[i]+ 5;
}
â€¢Bu kodda ilk dÃ¶ngÃ¼ A dizisini hesaplar, ikinci dÃ¶ngÃ¼ ise A'nÄ±n sonuÃ§larÄ±nÄ± C dizisine
iÅŸler.
â€¢A dizisine iki kez eriÅŸilir:
â€¢Birinci dÃ¶ngÃ¼de yazÄ±lÄ±r, ikinci dÃ¶ngÃ¼de okunur.
â€¢Bu da gereksiz bellek eriÅŸimine neden olur.

Derleyici OptimizasyonlarÄ±
Ã‡Ã¶zÃ¼m:
â€¢Bu iki dÃ¶ngÃ¼yÃ¼ tek bir dÃ¶ngÃ¼yebirleÅŸtirerek bellek eriÅŸimini optimize edebiliriz:
for (int i = 0; i < N; i++) {
A[i]= B[i] * 2;
C[i] = A[i] + 5;
}
â€¢A[i] birinci satÄ±rda hesaplanÄ±r ve hemen ikinci satÄ±rda kullanÄ±lÄ±r.
â€¢Tek bir dÃ¶ngÃ¼ baÅŸlatÄ±lÄ±r.
â€¢Bellek eriÅŸimi azaltÄ±lÄ±r.
Seri
programlama
kullanÄ±lmakta

Derleyici OptimizasyonlarÄ±
BaÄŸÄ±msÄ±z iÅŸlem adÄ±mlarÄ± iÃ§eren dÃ¶ngÃ¼ler varsa (Ã–rneÄŸin A[i]
Ã¶nce hesaplanÄ±p sonra C[i]'de kullanÄ±lÄ±yorsa)
Diziler arasÄ±ndaki veri baÄŸÄ±mlÄ±lÄ±ÄŸÄ± yoksa
Yada veri baÄŸÄ±mlÄ±lÄ±ÄŸÄ± kontrol ediliyorsa
Bellek performansÄ± artÄ±rÄ±lmak isteniyorsa
ïƒ¼
ïƒ¼
DÃ¶ngÃ¼ birleÅŸtirme ne zaman kullanÄ±lÄ±r?
ïƒ¼
ïƒ¼

Derleyici OptimizasyonlarÄ±
â€¢VektÃ¶rizasyon (Vectorization):
â€¢Tek Komut Ã‡oklu Veri (SIMD) paralelliÄŸiolarak da bilinen bir
optimizasyon tekniÄŸidir.
â€¢Bu teknik,
â€¢aynÄ± iÅŸlemci komutunun birden fazla veri elemanÄ±na aynÄ± anda
uygulanmasÄ±nÄ± saÄŸlar
â€¢Ã–zellikle diziler veya vektÃ¶rler Ã¼zerinde Ã§alÄ±ÅŸan dÃ¶ngÃ¼ler iÃ§in oldukÃ§a
etkilidir.
â€¢Modern iÅŸlemciler, SIMD komut setleri (SSE, AVX, Neon vb.) ile vektÃ¶r
iÅŸlemlerini hÄ±zlandÄ±rÄ±r.

Derleyici OptimizasyonlarÄ±
â€¢Ã–rneÄŸin 8 elemanlÄ± bir dizininher elemanÄ± 2 ile Ã§arpÄ±lmak istensin:
â€¢Skaler iÅŸlem yapÄ±lÄ±r. Yani standart bir for dÃ¶ngÃ¼sÃ¼yle her elemanÄ± tek tek Ã§arpÄ±lÄ±r:
int array[8] = {1, 2, 3, 4, 5, 6, 7, 8};
for (int i = 0; i < 8; i++) {
array[i] = array[i] * 2;
}
â€¢Ä°ÅŸlem AdÄ±mlarÄ±:
â€¢Ä°lk iterasyon: array[0] = 1 * 2
â€¢Ä°kinci iterasyon: array[1] = 2 * 2
â€¢ÃœÃ§Ã¼ncÃ¼ iterasyon: array[2] = 3 * 2
â€¢...
â€¢Sekizinci iterasyon: array[7] = 8 * 2
â€¢Toplamda 8 iÅŸlem yapÄ±lÄ±r (8 dÃ¶ngÃ¼ turu).
ï”
Bu iÅŸlem
vektÃ¶rleÅŸtirme
ile nasÄ±l olur?

Derleyici OptimizasyonlarÄ±
Ã‡Ã¶zÃ¼m 1:
â€¢4â€™lÃ¼ SIMDile VektÃ¶rizasyonda4 tane sayÄ± tek seferde iÅŸlenebilir.
int array[8] = {1, 2, 3, 4, 5, 6, 7, 8};
#pragma omp simd
for (int i = 0; i < 8; i++) {
array[i] = array[i] * 2;
}
â€¢Ä°ÅŸlem adÄ±mlarÄ±:
â€¢Ä°lk adÄ±mda iÅŸlemci 4 elemanÄ± aynÄ± andaÃ§arpar: {1, 2, 3, 4} * 2 â†’ {2, 4, 6, 8}
â€¢Ä°kinci adÄ±mda diÄŸer 4 elemanÄ± aynÄ± anda Ã§arpar: {5, 6, 7, 8} * 2 â†’ {10, 12, 14, 16}
â€¢Toplamda 2 dÃ¶ngÃ¼ turu ile iÅŸlem tamamlanÄ±r.

Derleyici OptimizasyonlarÄ±
Ã‡Ã¶zÃ¼m 2:
â€¢8â€™lÃ¼ SIMDile VektÃ¶rizasyonda8tane sayÄ± tek seferde iÅŸlenebilir.
int array[8] = {1, 2, 3, 4, 5, 6, 7, 8};
#pragma omp simd
for (int i = 0; i < 8; i++) {
array[i] = array[i] * 2;
}
â€¢Ä°ÅŸlem adÄ±mlarÄ±:
â€¢Tek adÄ±mda iÅŸlemci 8elemanÄ± aynÄ± andaÃ§arpar:
â€¢{1, 2, 3, 4, 5, 6, 7, 8} * 2 â†’ {2, 4, 6, 8, 10, 12, 14, 16}
â€¢Toplamda 1 dÃ¶ngÃ¼ turu ile iÅŸlem tamamlanÄ±r.

Derleyici OptimizasyonlarÄ±
Tek bir saat dÃ¶ngÃ¼sÃ¼nde birden fazla veri elemanÄ±nÄ± iÅŸler.
Ä°ÅŸlem sÃ¼resini hÄ±zlandÄ±rÄ±r.
Bellekten okuma ve yazma iÅŸlemlerinin sayÄ±sÄ±nÄ± azaltÄ±r.
GÃ¼Ã§ tÃ¼ketimini azaltÄ±r.
ïƒ¼
ïƒ¼
VektÃ¶rizasyonun avantajlarÄ± nelerdir?
ïƒ¼
ïƒ¼

Performans Profilleme ve Hata AyÄ±klama
â€¢Eksaskala sistemlerde, iÅŸlemci veya Ã§ekirdek sayÄ±sÄ± arttÄ±kÃ§a uygulamanÄ±n
performansÄ± analiz edilir.
â€¢Profilleme ve hata ayÄ±klama,
â€¢Eksaskala sistemlerde kod verimliliÄŸini optimize etmek ve performans
sorunlarÄ±nÄ± tespit etmek iÃ§in kullanÄ±lÄ±r.
â€¢Profilleme,
â€¢programÄ±n Ã§alÄ±ÅŸma zamanÄ± davranÄ±ÅŸÄ±nÄ± analiz etmeye ve darboÄŸazlarÄ± tespit
etmeyeyardÄ±mcÄ± olur.
â€¢Hata ayÄ±klama,
â€¢performans, eÅŸzamanlÄ±lÄ±k ve kaynak kullanÄ±mÄ±yla ilgili hatalarÄ± giderir ve
programÄ±n doÄŸruluÄŸunu saÄŸlar.

Performans Profilleme ve Hata AyÄ±klama
â€¢Eksaskala sistemlerde profilleme araÃ§larÄ± genel olarak iÅŸlemci, bellek ve I/O
kullanÄ±mÄ±gibi farklÄ± kaynaklarÄ±n nasÄ±l kullanÄ±ldÄ±ÄŸÄ±nÄ± analiz eder.
â€¢Eksaskala sistemlerde en sÄ±k kullanÄ±lan profilleme araÃ§lar:
â€¢Intel VTune Amplifier
â€¢Cray Pat
â€¢TAU (Tuning and Analysis Utilities)
â€¢gprof
â€¢perf

Performans Profilleme ve Hata AyÄ±klama
â€¢Eksaskala sistemlerde hata ayÄ±klama araÃ§larÄ± genel olarak bellek hatalarÄ±, veri
yarÄ±ÅŸlarÄ± gibi hatalarÄ± analiz eder.
â€¢Eksaskala sistemlerde en sÄ±k kullanÄ±lan hata ayÄ±klama araÃ§larÄ±:
â€¢TotalView
â€¢GDB (GNU Debugger)
â€¢Allinea DDT
â€¢Intel Debugger (IDB)
- **Ä°stenen Toplam Soru SayÄ±sÄ±:** 10 soru
- **Zorluk Seviyesi:** mixed

// ----------------------------------------------------
// ------------- METÄ°N ANALÄ°Z SÃœRECÄ° -----------------
// ----------------------------------------------------

**ğŸ” Ä°Ã‡ERÄ°K ANALÄ°Z ADIMLARI:**
1. Ã–nce metni dikkatlice oku ve anla
2. "Konu Bilgileri" bÃ¶lÃ¼mÃ¼ndeki "AKTÄ°F KONULAR (SORU ÃœRETÄ°LECEK)" listesindeki alt konulara odaklan
3. Her bir aktif alt konu iÃ§in anahtar kavramlarÄ± tespit et
4. Her kavram iÃ§in Ã¶ÄŸrenilmesi gereken temel noktalarÄ± listele
5. Ä°Ã§eriÄŸin mantÄ±k akÄ±ÅŸÄ±nÄ± ve bÃ¶lÃ¼mleri arasÄ±ndaki iliÅŸkiyi kavra

**âš ï¸ METÄ°N SORUNLARIYLA BAÅA Ã‡IKMA:**
- EÄŸer metin formatÄ± bozuk gÃ¶rÃ¼nÃ¼yorsa (satÄ±r sonlarÄ± eksik vb.), cÃ¼mle yapÄ±sÄ±nÄ± anlamaya Ã§alÄ±ÅŸ
- AnlamsÄ±z veya hatalÄ± karakterler varsa yok say
- Metin kÄ±sÄ±mlarÄ± eksik veya kopuk gÃ¶rÃ¼nÃ¼yorsa, mevcut bilgilerden yararlanan sorular oluÅŸtur
- TÃ¼rkÃ§e karakter sorunlarÄ± varsa (ÅŸ, Ã§, ÄŸ, Ã¼, Ã¶, Ä±) anlamÄ± koruyarak dÃ¼zelt

// ----------------------------------------------------
// ------------- SORU OLUÅTURMA KURALLARI ------------
// ----------------------------------------------------

**â­ ALT KONU DAÄILIMI VE SORU KURGULAMASI:**
1. SADECE "Konu Bilgileri" bÃ¶lÃ¼mÃ¼ndeki "AKTÄ°F KONULAR (SORU ÃœRETÄ°LECEK)" listesinde belirtilen alt konular iÃ§in soru Ã¼ret
2. "BEKLEYEN KONULAR (SORU ÃœRETÄ°LMEYECEK)" listesindeki konulardan KESÄ°NLÄ°KLE soru ÃœRETME
3. Her aktif alt konu iÃ§in tam olarak o alt konu yanÄ±nda belirtilen sayÄ±da soru Ã¼ret
   Ã–rneÄŸin: "Nesne YÃ¶nelimli Programlama (3 soru)" ifadesi, bu konu iÃ§in tam 3 soru oluÅŸturulmalÄ±dÄ±r
4. Toplam soru sayÄ±sÄ±nÄ±n 10 olduÄŸundan emin ol (Bu sayÄ±, aktif konulardaki toplam soru sayÄ±sÄ±na eÅŸit olmalÄ±dÄ±r)
5. Belirtilen aktif alt konular ve soru sayÄ±larÄ±na MUTLAKA UYULMALIDIR
6. Her sorunun hangi alt konuya ait olduÄŸu JSON Ã§Ä±ktÄ±sÄ±nda "subTopicName" alanÄ±nda AÃ‡IKÃ‡A belirtilmelidir
7. Her soruyu Ã¼retirken, o sorunun hangi aktif alt konudan geldiÄŸini mutlaka kontrol et
8. Soru daÄŸÄ±lÄ±mlarÄ± dengesiz olabilir! Ã–rneÄŸin: "Veri YapÄ±larÄ±" iÃ§in 5 soru, "Algoritma Analizi" iÃ§in 2 soru

**ğŸ“Š ZORLUK SEVÄ°YELERÄ° (SADECE Ä°NGÄ°LÄ°ZCE KULLAN):**
- "easy" (kolay): Temel hatÄ±rlama ve anlama sorularÄ±
- "medium" (orta): Uygulama ve analiz sorularÄ±
- "hard" (zor): KarmaÅŸÄ±k analiz, deÄŸerlendirme ve yaratma sorularÄ±
- "mixed" (karÄ±ÅŸÄ±k): FarklÄ± zorluk seviyelerinin karÄ±ÅŸÄ±mÄ±

**ğŸ§  BLOOM TAKSONOMÄ°SÄ° DÃœZEYLERÄ°:**
- Kolay (easy): "remembering", "understanding"
- Orta (medium): "applying", "analyzing" (temel dÃ¼zeyde)
- Zor (hard): "analyzing" (karmaÅŸÄ±k), "evaluating", "creating"

**ğŸ“ SORU TÃœRLERÄ° VE KULLANIM:**
- "multiple_choice": KavramlarÄ± test etmek iÃ§in en yaygÄ±n format (4 ÅŸÄ±k)
- "true_false": YaygÄ±n yanlÄ±ÅŸ anlamalarÄ± test etmek iÃ§in ideal
- "fill_in_blank": Terminoloji ve kesin bilgi iÃ§in
- "short_answer": Ã–ÄŸrencinin kendi ifadesiyle aÃ§Ä±klamasÄ±nÄ± gerektiren konular iÃ§in

**ğŸ“‹ TEMEL KURALLAR:**
1. Sorular SADECE verilen iÃ§eriÄŸe dayanmalÄ±, dÄ±ÅŸarÄ±dan bilgi eklenmemeli
2. Her soru bir alt konuyu Ã¶lÃ§meli ve doÄŸrudan iÃ§erikle ilgili olmalÄ±
3. Her sorunun TEK doÄŸru cevabÄ± olmalÄ±, bu cevap aÃ§Ä±kÃ§a iÃ§erikte belirtilmiÅŸ olmalÄ±
4. Ã‡eldiriciler (yanlÄ±ÅŸ ÅŸÄ±klar) makul ama ayÄ±rt edilebilir olmalÄ±
5. Konu daÄŸÄ±lÄ±mÄ±nda belirtilen aÄŸÄ±rlÄ±klara uyulmalÄ±
6. Sorular kavramsal anlayÄ±ÅŸÄ± Ã¶lÃ§meli, sadece ezber bilgiyi deÄŸil
7. Metin iÃ§indeki kelimeler birebir kopyalanmak yerine yeniden ifade edilmeli

**ğŸ’¡ AÃ‡IKLAMA YAZMA KURALLARI:**
- Her aÃ§Ä±klama, doÄŸru cevabÄ± net ÅŸekilde belirtmeli
- AÃ§Ä±klamada Ã¶ÄŸrenciyi iÃ§eriÄŸin ilgili bÃ¶lÃ¼mÃ¼ne yÃ¶nlendirmeli
- Sadece neyin doÄŸru olduÄŸunu deÄŸil, neden doÄŸru olduÄŸunu da aÃ§Ä±klamalÄ±
- Ã‡eldiricilerin neden yanlÄ±ÅŸ olduÄŸunu kÄ±saca belirtmeli
- KÄ±sa ve Ã¶z olmalÄ±, ama yeterince bilgilendirici olmalÄ±

// ----------------------------------------------------
// -------------- JSON Ã‡IKTI FORMATI -----------------
// ----------------------------------------------------

**âš™ï¸ JSON Ã‡IKTI KURALLARI:**
- YanÄ±t SADECE geÃ§erli bir JSON nesnesi olmalÄ±dÄ±r, ek aÃ§Ä±klama iÃ§ermemelidir
- JSON dÄ±ÅŸÄ±nda hiÃ§bir ek metin eklenmemelidir
- JSON yapÄ±sÄ± tam ve doÄŸru olmalÄ± - tÃ¼m parantezleri dengeli olmalÄ±
- Zorunlu alanlar: id, questionText, options, correctAnswer, explanation, subTopicName, difficulty
- Her soru iÃ§in zorluk seviyesi SADECE Ä°ngilizce olmalÄ± ("easy", "medium", "hard", "mixed")

**ğŸ“„ JSON FORMATI:**
```
{
  "questions": [
    {
      "id": "q1",
      "questionText": "Soru metni?",
      "questionType": "multiple_choice",
      "cognitiveDomain": "remembering",
      "options": ["SeÃ§enek A", "SeÃ§enek B", "SeÃ§enek C", "SeÃ§enek D"],
      "correctAnswer": "SeÃ§enek B",
      "explanation": "DoÄŸru cevabÄ±n aÃ§Ä±klamasÄ±",
      "subTopicName": "Nesne YÃ¶nelimli Programlama",
      "normalizedSubTopicName": "nesne_yonelimli_programlama",
      "difficulty": "medium"
    },
    {
      "id": "q2",
      "questionText": "Ä°kinci soru metni?",
      "questionType": "multiple_choice",
      "cognitiveDomain": "understanding",
      "options": ["SeÃ§enek A", "SeÃ§enek B", "SeÃ§enek C", "SeÃ§enek D"],
      "correctAnswer": "SeÃ§enek A",
      "explanation": "DoÄŸru cevabÄ±n aÃ§Ä±klamasÄ±",
      "subTopicName": "Nesne YÃ¶nelimli Programlama",
      "normalizedSubTopicName": "nesne_yonelimli_programlama",
      "difficulty": "easy"
    },
    {
      "id": "q3",
      "questionText": "ÃœÃ§Ã¼ncÃ¼ soru metni?",
      "questionType": "multiple_choice",
      "cognitiveDomain": "applying",
      "options": ["SeÃ§enek A", "SeÃ§enek B", "SeÃ§enek C", "SeÃ§enek D"],
      "correctAnswer": "SeÃ§enek C",
      "explanation": "DoÄŸru cevabÄ±n aÃ§Ä±klamasÄ±",
      "subTopicName": "Nesne YÃ¶nelimli Programlama",
      "normalizedSubTopicName": "nesne_yonelimli_programlama",
      "difficulty": "medium"
    },
    {
      "id": "q4",
      "questionText": "BaÅŸka bir alt konudan soru?",
      "questionType": "multiple_choice",
      "cognitiveDomain": "analyzing",
      "options": ["SeÃ§enek A", "SeÃ§enek B", "SeÃ§enek C", "SeÃ§enek D"],
      "correctAnswer": "SeÃ§enek D",
      "explanation": "DoÄŸru cevabÄ±n aÃ§Ä±klamasÄ±",
      "subTopicName": "Algoritma Analizi",
      "normalizedSubTopicName": "algoritma_analizi",
      "difficulty": "hard"
    }
  ]
}
```

// ----------------------------------------------------
// -------------- KALÄ°TE KRÄ°TERLERÄ° ------------------
// ----------------------------------------------------

**ğŸ¯ SORU KALÄ°TESÄ° KRÄ°TERLERÄ°:**
1. Ä°Ã‡ERÄ°K ODAKLILIK: Her soru, direkt olarak verilen metinden Ã§Ä±karÄ±lmalÄ±
2. AÃ‡IKLIK: Soru ifadeleri aÃ§Ä±k, net ve anlaÅŸÄ±lÄ±r olmalÄ±
3. UYGUNLUK: Zorluk seviyesi ve biliÅŸsel dÃ¼zey uyumlu olmalÄ±
4. DENGELÄ° Ã‡ELDÄ°RÄ°CÄ°LER: YanlÄ±ÅŸ ÅŸÄ±klar mantÄ±klÄ± ama aÃ§Ä±kÃ§a yanlÄ±ÅŸ olmalÄ±
5. KAVRAMSAL DERINLIK: YÃ¼zeysel bilgi yerine kavramsal anlayÄ±ÅŸÄ± Ã¶lÃ§meli
6. DÄ°L KALÄ°TESÄ°: TÃ¼rkÃ§e dilbilgisi ve yazÄ±m kurallarÄ±na uygun olmalÄ±

**âœ… SON KONTROLLER:**
- TÃ¼m sorularÄ±n doÄŸru cevaplarÄ± kesinlikle metinde yer almalÄ±
- Zorluk seviyeleri MUTLAKA Ä°ngilizce olmalÄ± ("easy", "medium", "hard", "mixed")
- JSON formatÄ±nÄ±n doÄŸruluÄŸundan emin ol
- Sorular farklÄ± biliÅŸsel dÃ¼zeyleri iÃ§ermeli
- TÃ¼m gerekli alanlar doldurulmalÄ±
- ALT KONU DAÄILIMI ve SORU SAYISI:
  1. Toplam soru sayÄ±sÄ± tam olarak 10 adet olmalÄ± (aktif konulardaki toplam soru sayÄ±sÄ±yla eÅŸleÅŸmeli)
  2. "Konu Bilgileri" bÃ¶lÃ¼mÃ¼ndeki "AKTÄ°F KONULAR (SORU ÃœRETÄ°LECEK)" listesindeki HER BÄ°R alt konu iÃ§in belirtilen SORU SAYISINA MUTLAKA uyulmalÄ±
     Ã–rneÄŸin: "Veri TabanÄ± Sistemleri (3 soru)" yazÄ±yorsa, bu konudan tam 3 soru Ã¼retilmeli
  3. "BEKLEYEN KONULAR (SORU ÃœRETÄ°LMEYECEK)" listesindeki konulardan KESÄ°NLÄ°KLE soru Ã¼retilmediÄŸinden emin ol
  4. Her sorunun "subTopicName" alanÄ±nda, o sorunun geldiÄŸi alt konunun TAM ADI belirtilmeli
     Ã–rneÄŸin: "Nesne YÃ¶nelimli Programlama", "Veri YapÄ±larÄ±" gibi konu adlarÄ± aynen kullanÄ±lmalÄ±
- Her alt konu iÃ§in sorularÄ±n zorluk daÄŸÄ±lÄ±mÄ± dengeli olmalÄ±

// ====================================================
// ================ PROMPT SONU ======================
// ====================================================
```



## AI YanÄ±tÄ±:
```json
```json
{
  "questions": [
    {
      "id": "q1",
      "questionText": "Eksaskala sistemlerin yÃ¼ksek hesaplama gÃ¼cÃ¼nÃ¼ kullanabilmeleri iÃ§in tasarÄ±mcÄ±lara kÃ¶prÃ¼ gÃ¶revi gÃ¶ren temel unsur aÅŸaÄŸÄ±dakilerden hangisidir?",
      "questionType": "multiple_choice",
      "cognitiveDomain": "understanding",
      "options": [
        "DonanÄ±m optimizasyonlarÄ±",
        "Programlama modelleri ve araÃ§larÄ±",
        "Veri depolama Ã§Ã¶zÃ¼mleri",
        "AÄŸ iletiÅŸim protokolleri"
      ],
      "correctAnswer": "Programlama modelleri ve araÃ§larÄ±",
      "explanation": "Programlama modelleri ve araÃ§larÄ±, tasarÄ±mcÄ±lara eksaskala sistemlerin yÃ¼ksek hesaplama gÃ¼cÃ¼nÃ¼ kullanabilmeleri iÃ§in bir kÃ¶prÃ¼ gÃ¶revi gÃ¶rÃ¼r ve eksaskala bilgisayar sistemleri iÃ§in kritik bir rol oynar. (Sunu 3, Programlama Modelleri ve AraÃ§larÄ±)",
      "subTopicName": "Programlama Modelleri Ve Ara Lar",
      "normalizedSubTopicName": "programlama_modelleri_ve_ara_lar",
      "difficulty": "medium"
    },
    {
      "id": "q2",
      "questionText": "AÅŸaÄŸÄ±dakilerden hangisi eksaskala sistemlerde programlamada kullanÄ±lan en temel modellerden ve araÃ§lardan biri deÄŸildir?",
      "questionType": "multiple_choice",
      "cognitiveDomain": "remembering",
      "options": [
        "Paralel Programlama ParadigmalarÄ±",
        "Derleyici OptimizasyonlarÄ±",
        "Performans Profilleme ve Hata AyÄ±klama",
        "Veri ÅŸifreleme teknikleri"
      ],
      "correctAnswer": "Veri ÅŸifreleme teknikleri",
      "explanation": "Paralel Programlama ParadigmalarÄ±, Derleyici OptimizasyonlarÄ± ve Performans Profilleme ve Hata AyÄ±klama, eksaskala sistemlerde programlamada kullanÄ±lan en temel modeller ve araÃ§lardÄ±r. Veri ÅŸifreleme teknikleri bu kapsamda yer almaz. (Sunu 3, Programlama Modelleri ve AraÃ§larÄ±)",
      "subTopicName": "Programlama Modelleri Ve Ara Lar",
      "normalizedSubTopicName": "programlama_modelleri_ve_ara_lar",
      "difficulty": "easy"
    },
    {
      "id": "q3",
      "questionText": "AÅŸaÄŸÄ±dakilerden hangisi paralel programlama paradigmasÄ±nÄ±n temel amacÄ±dÄ±r?",
      "questionType": "multiple_choice",
      "cognitiveDomain": "understanding",
      "options": [
        "Ä°ÅŸlemleri sÄ±ralÄ± bir ÅŸekilde yÃ¼rÃ¼tmek",
        "Bir iÅŸlemi kÃ¼Ã§Ã¼k parÃ§alara bÃ¶lerek aynÄ± anda birden fazla iÅŸlemcide yÃ¼rÃ¼tmek",
        "Bellek kullanÄ±mÄ±nÄ± en aza indirmek",
        "Enerji tÃ¼ketimini artÄ±rmak"
      ],
      "correctAnswer": "Bir iÅŸlemi kÃ¼Ã§Ã¼k parÃ§alara bÃ¶lerek aynÄ± anda birden fazla iÅŸlemcide yÃ¼rÃ¼tmek",
      "explanation": "Paralel programlama paradigmasÄ±, bir iÅŸlemin kÃ¼Ã§Ã¼k parÃ§alara bÃ¶lÃ¼nerek aynÄ± anda birden fazla iÅŸlemcide yÃ¼rÃ¼tÃ¼lmesini saÄŸlayan yazÄ±lÄ±mlardÄ±r. Bu, bÃ¼yÃ¼k Ã¶lÃ§ekli hesaplamalarda performansÄ± maksimize etmek iÃ§in kritik bir bileÅŸendir. (Sunu 3, Paralel Programlama ParadigmalarÄ±)",
      "subTopicName": "Paralel Programlama Paradigmalar",
      "normalizedSubTopicName": "paralel_programlama_paradigmalar",
      "difficulty": "medium"
    },
    {
      "id": "q4",
      "questionText": "Eksaskala sistemlerde kullanÄ±lan baÅŸlÄ±ca paralel programlama paradigmalarÄ± arasÄ±nda aÅŸaÄŸÄ±dakilerden hangisi yer almaz?",
      "questionType": "multiple_choice",
      "cognitiveDomain": "remembering",
      "options": [
        "PaylaÅŸÄ±mlÄ± Bellek ParadigmasÄ±",
        "DaÄŸÄ±tÄ±k Bellek ParadigmasÄ±",
        "Hibrit Paralel Programlama",
        "Nesne YÃ¶nelimli Programlama"
      ],
      "correctAnswer": "Nesne YÃ¶nelimli Programlama",
      "explanation": "Eksaskala sistemlerde kullanÄ±lan baÅŸlÄ±ca paralel programlama paradigmalarÄ± ÅŸunlardÄ±r: PaylaÅŸÄ±mlÄ± Bellek ParadigmasÄ±, DaÄŸÄ±tÄ±k Bellek ParadigmasÄ± ve Hibrit Paralel Programlama. (Sunu 3, Paralel Programlama ParadigmalarÄ±)",
      "subTopicName": "Paralel Programlama Paradigmalar",
      "normalizedSubTopicName": "paralel_programlama_paradigmalar",
      "difficulty": "easy"
    },
    {
      "id": "q5",
      "questionText": "Derleyici optimizasyonlarÄ±nÄ±n temel amacÄ± nedir?",
      "questionType": "multiple_choice",
      "cognitiveDomain": "understanding",
      "options": [
        "Kaynak kodu daha okunabilir hale getirmek",
        "Kaynak kodun yÃ¼ksek verimli makine koduna dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmesi sÃ¼recini iyileÅŸtirmek",
        "HatalarÄ± ayÄ±klama sÃ¼recini kolaylaÅŸtÄ±rmak",
        "Bellek kullanÄ±mÄ±nÄ± artÄ±rmak"
      ],
      "correctAnswer": "Kaynak kodun yÃ¼ksek verimli makine koduna dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmesi sÃ¼recini iyileÅŸtirmek",
      "explanation": "Derleyici optimizasyonlarÄ±, kaynak kodun yÃ¼ksek verimli makine koduna dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmesi sÃ¼recidir. Eksaskala sistemlerde amaÃ§, hesaplama verimliliÄŸini artÄ±rmak ve bellek eriÅŸim gecikmesini azaltmaktÄ±r. (Sunu 3, Derleyici OptimizasyonlarÄ±)",
      "subTopicName": "Derleyici Optimizasyonlar",
      "normalizedSubTopicName": "derleyici_optimizasyonlar",
      "difficulty": "medium"
    },
    {
      "id": "q6",
      "questionText": "AÅŸaÄŸÄ±dakilerden hangisi derleyici optimizasyonu ile performans iyileÅŸtirmesinde kullanÄ±lan tekniklerden biri deÄŸildir?",
      "questionType": "multiple_choice",
      "cognitiveDomain": "remembering",
      "options": [
        "DÃ¶ngÃ¼ aÃ§ma (Loop Unrolling)",
        "DÃ¶ngÃ¼ birleÅŸtirme (Loop Fusion)",
        "DÃ¶ngÃ¼ vektÃ¶rleÅŸtirme (Loop Vectorization)",
        "Veri ÅŸifreleme (Data Encryption)"
      ],
      "correctAnswer": "Veri ÅŸifreleme (Data Encryption)",
      "explanation": "DÃ¶ngÃ¼ aÃ§ma, dÃ¶ngÃ¼ birleÅŸtirme ve dÃ¶ngÃ¼ vektÃ¶rleÅŸtirme teknikleri, derleyici optimizasyonu ile performans iyileÅŸtirmesinde kullanÄ±lan tekniklerdir. Veri ÅŸifreleme bu kapsamda yer almaz. (Sunu 3, Derleyici OptimizasyonlarÄ±)",
      "subTopicName": "Derleyici Optimizasyonlar",
      "normalizedSubTopicName": "derleyici_optimizasyonlar",
      "difficulty": "easy"
    },
    {
      "id": "q7",
      "questionText": "Eksaskala sistemlerde performans profilinin temel amacÄ± nedir?",
      "questionType": "multiple_choice",
      "cognitiveDomain": "understanding",
      "options": [
        "ProgramÄ±n kaynak kodunu deÄŸiÅŸtirmek",
        "ProgramÄ±n Ã§alÄ±ÅŸma zamanÄ± davranÄ±ÅŸÄ±nÄ± analiz etmek ve darboÄŸazlarÄ± tespit etmek",
        "Hata ayÄ±klama sÃ¼recini karmaÅŸÄ±klaÅŸtÄ±rmak",
        "Bellek kullanÄ±mÄ±nÄ± azaltmak"
      ],
      "correctAnswer": "ProgramÄ±n Ã§alÄ±ÅŸma zamanÄ± davranÄ±ÅŸÄ±nÄ± analiz etmek ve darboÄŸazlarÄ± tespit etmek",
      "explanation": "Profilleme, programÄ±n Ã§alÄ±ÅŸma zamanÄ± davranÄ±ÅŸÄ±nÄ± analiz etmeye ve darboÄŸazlarÄ± tespit etmeye yardÄ±mcÄ± olur. Bu, eksaskala sistemlerde kod verimliliÄŸini optimize etmek iÃ§in kullanÄ±lÄ±r. (Sunu 3, Performans Profilleme ve Hata AyÄ±klama)",
      "subTopicName": "Performans Profilleme Ve Hata Ay Klama",
      "normalizedSubTopicName": "performans_profilleme_ve_hata_ay_klama",
      "difficulty": "medium"
    },
    {
      "id": "q8",
      "questionText": "AÅŸaÄŸÄ±dakilerden hangisi eksaskala sistemlerde en sÄ±k kullanÄ±lan profilleme araÃ§larÄ±ndan biri deÄŸildir?",
      "questionType": "multiple_choice",
      "cognitiveDomain": "remembering",
      "options": [
        "Intel VTune Amplifier",
        "Cray Pat",
        "TAU (Tuning and Analysis Utilities)",
        "Wireshark"
      ],
      "correctAnswer": "Wireshark",
      "explanation": "Intel VTune Amplifier, Cray Pat ve TAU (Tuning and Analysis Utilities), eksaskala sistemlerde en sÄ±k kullanÄ±lan profilleme araÃ§larÄ±ndandÄ±r. Wireshark bir aÄŸ protokolÃ¼ analiz aracÄ±dÄ±r ve bu kapsamda yer almaz. (Sunu 3, Performans Profilleme ve Hata AyÄ±klama)",
      "subTopicName": "Performans Profilleme Ve Hata Ay Klama",
      "normalizedSubTopicName": "performans_profilleme_ve_hata_ay_klama",
      "difficulty": "easy"
    },
    {
      "id": "q9",
      "questionText": "PaylaÅŸÄ±mlÄ± bellek paradigmasÄ± hangi tÃ¼r iÅŸlemciler iÃ§in idealdir ve bu paradigmada tÃ¼m iÅŸlemciler neye eriÅŸir?",
      "questionType": "multiple_choice",
      "cognitiveDomain": "understanding",
      "options": [
        "Tek Ã§ekirdekli iÅŸlemciler; Ã¶zel belleÄŸe",
        "Ã‡ok Ã§ekirdekli iÅŸlemciler; ortak belleÄŸe",
        "GPU'lar; ayrÄ±lmÄ±ÅŸ belleÄŸe",
        "FPGA'lar; daÄŸÄ±tÄ±k belleÄŸe"
      ],
      "correctAnswer": "Ã‡ok Ã§ekirdekli iÅŸlemciler; ortak belleÄŸe",
      "explanation": "PaylaÅŸÄ±mlÄ± bellek paradigmasÄ±, Ã§ok Ã§ekirdekli iÅŸlemciler iÃ§in idealdir; tÃ¼m iÅŸlemciler ortak belleÄŸe eriÅŸir. Bu paradigmada OpenMP, mevcut koda direktifler ekleyerek uygulama geliÅŸtirmeyi kolaylaÅŸtÄ±rÄ±r ve dÃ¼ÅŸÃ¼k iletiÅŸim gecikmesi avantajdÄ±r. (Sunu 3, Paralel Programlama ParadigmalarÄ±)",
      "subTopicName": "Payla Ml Bellek Paradigmas",
      "normalizedSubTopicName": "payla_ml_bellek_paradigmas",
      "difficulty": "medium"
    },
    {
      "id": "q10",
      "questionText": "OpenMP'nin temel iÅŸlevi nedir ve hangi tÃ¼r mimarilerde paralel uygulamalar geliÅŸtirmek iÃ§in kullanÄ±lÄ±r?",
      "questionType": "multiple_choice",
      "cognitiveDomain": "remembering",
      "options": [
        "DaÄŸÄ±tÄ±k bellekli ortamlarda veri alÄ±ÅŸveriÅŸi saÄŸlamak; tek Ã§ekirdekli iÅŸlemcilerde",
        "Ã‡ok Ã§ekirdekli iÅŸlemciler ve paylaÅŸÄ±mlÄ± bellek mimarilerinde paralel uygulamalar geliÅŸtirmek; derleyici direktifleri kullanmak",
        "Bellek hatalarÄ±nÄ± ayÄ±klamak; GPU'larda",
        "AÄŸ iletiÅŸimini optimize etmek; FPGA'larda"
      ],
      "correctAnswer": "Ã‡ok Ã§ekirdekli iÅŸlemciler ve paylaÅŸÄ±mlÄ± bellek mimarilerinde paralel uygulamalar geliÅŸtirmek; derleyici direktifleri kullanmak",
      "explanation": "OpenMP (Open Multi-Processing), Ã§ok Ã§ekirdekli iÅŸlemciler ve paylaÅŸÄ±mlÄ± bellek mimarileri ile paralel uygulamalar geliÅŸtirmek iÃ§in kullanÄ±lÄ±r. Paralellik saÄŸlamak iÃ§in derleyici direktifleri kullanÄ±lÄ±r. (Sunu 3, Paralel Programlama ParadigmalarÄ±)",
      "subTopicName": "Payla Ml Bellek Paradigmas",
      "normalizedSubTopicName": "payla_ml_bellek_paradigmas",
      "difficulty": "easy"
    }
  ]
}
```
```



## Ä°ÅŸlenen Sorular Analizi:

- Toplam Soru SayÄ±sÄ±: 10
- Alt Konu DaÄŸÄ±lÄ±mÄ±:

  - Programlama Modelleri Ve Ara Lar: 2 soru
  - Paralel Programlama Paradigmalar: 2 soru
  - Derleyici Optimizasyonlar: 2 soru
  - Performans Profilleme Ve Hata Ay Klama: 2 soru
  - Payla Ml Bellek Paradigmas: 2 soru


### Soru Ã–rnekleri (Her Alt Konudan 1 Adet):

#### Programlama Modelleri Ve Ara Lar:
- Soru: Eksaskala sistemlerin yÃ¼ksek hesaplama gÃ¼cÃ¼nÃ¼ kullanabilmeleri iÃ§in tasarÄ±mcÄ±lara kÃ¶prÃ¼ gÃ¶revi gÃ¶ren temel unsur aÅŸaÄŸÄ±dakilerden hangisidir?
- SeÃ§enekler: DonanÄ±m optimizasyonlarÄ± | Programlama modelleri ve araÃ§larÄ± | Veri depolama Ã§Ã¶zÃ¼mleri | AÄŸ iletiÅŸim protokolleri
- DoÄŸru Cevap: Programlama modelleri ve araÃ§larÄ±
- Zorluk: medium

#### Paralel Programlama Paradigmalar:
- Soru: AÅŸaÄŸÄ±dakilerden hangisi paralel programlama paradigmasÄ±nÄ±n temel amacÄ±dÄ±r?
- SeÃ§enekler: Ä°ÅŸlemleri sÄ±ralÄ± bir ÅŸekilde yÃ¼rÃ¼tmek | Bir iÅŸlemi kÃ¼Ã§Ã¼k parÃ§alara bÃ¶lerek aynÄ± anda birden fazla iÅŸlemcide yÃ¼rÃ¼tmek | Bellek kullanÄ±mÄ±nÄ± en aza indirmek | Enerji tÃ¼ketimini artÄ±rmak
- DoÄŸru Cevap: Bir iÅŸlemi kÃ¼Ã§Ã¼k parÃ§alara bÃ¶lerek aynÄ± anda birden fazla iÅŸlemcide yÃ¼rÃ¼tmek
- Zorluk: medium

#### Derleyici Optimizasyonlar:
- Soru: Derleyici optimizasyonlarÄ±nÄ±n temel amacÄ± nedir?
- SeÃ§enekler: Kaynak kodu daha okunabilir hale getirmek | Kaynak kodun yÃ¼ksek verimli makine koduna dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmesi sÃ¼recini iyileÅŸtirmek | HatalarÄ± ayÄ±klama sÃ¼recini kolaylaÅŸtÄ±rmak | Bellek kullanÄ±mÄ±nÄ± artÄ±rmak
- DoÄŸru Cevap: Kaynak kodun yÃ¼ksek verimli makine koduna dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lmesi sÃ¼recini iyileÅŸtirmek
- Zorluk: medium

#### Performans Profilleme Ve Hata Ay Klama:
- Soru: Eksaskala sistemlerde performans profilinin temel amacÄ± nedir?
- SeÃ§enekler: ProgramÄ±n kaynak kodunu deÄŸiÅŸtirmek | ProgramÄ±n Ã§alÄ±ÅŸma zamanÄ± davranÄ±ÅŸÄ±nÄ± analiz etmek ve darboÄŸazlarÄ± tespit etmek | Hata ayÄ±klama sÃ¼recini karmaÅŸÄ±klaÅŸtÄ±rmak | Bellek kullanÄ±mÄ±nÄ± azaltmak
- DoÄŸru Cevap: ProgramÄ±n Ã§alÄ±ÅŸma zamanÄ± davranÄ±ÅŸÄ±nÄ± analiz etmek ve darboÄŸazlarÄ± tespit etmek
- Zorluk: medium

#### Payla Ml Bellek Paradigmas:
- Soru: PaylaÅŸÄ±mlÄ± bellek paradigmasÄ± hangi tÃ¼r iÅŸlemciler iÃ§in idealdir ve bu paradigmada tÃ¼m iÅŸlemciler neye eriÅŸir?
- SeÃ§enekler: Tek Ã§ekirdekli iÅŸlemciler; Ã¶zel belleÄŸe | Ã‡ok Ã§ekirdekli iÅŸlemciler; ortak belleÄŸe | GPU'lar; ayrÄ±lmÄ±ÅŸ belleÄŸe | FPGA'lar; daÄŸÄ±tÄ±k belleÄŸe
- DoÄŸru Cevap: Ã‡ok Ã§ekirdekli iÅŸlemciler; ortak belleÄŸe
- Zorluk: medium

